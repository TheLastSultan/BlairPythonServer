schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

scalar bigint

scalar Boolean

scalar Float

scalar float8

scalar Int

scalar jsonb

scalar String

scalar timestamptz

scalar uuid

"""
unique or primary key constraints on table "Assessment_AssessmentQuestion"
"""
enum Assessment_AssessmentQuestion_constraint {
  """
  unique or primary key constraint on columns "question_id", "assessment_id"
  """
  AssessmentQuestionIndex
  """
  unique or primary key constraint on columns "id"
  """
  Assessment_AssessmentQuestion_pkey
}

"""
select columns of table "Assessment_AssessmentQuestion"
"""
enum Assessment_AssessmentQuestion_select_column {
  """
  column name
  """
  assessment_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  question_id
}

"""
update columns of table "Assessment_AssessmentQuestion"
"""
enum Assessment_AssessmentQuestion_update_column {
  """
  column name
  """
  assessment_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  question_id
}

"""
unique or primary key constraints on table "Assessment"
"""
enum Assessment_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Assessment_pkey
}

"""
select columns of table "Assessment"
"""
enum Assessment_select_column {
  """
  column name
  """
  company_id
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  difficulty
  """
  column name
  """
  id
  """
  column name
  """
  metadata
  """
  column name
  """
  title
  """
  column name
  """
  updated_at
}

"""
update columns of table "Assessment"
"""
enum Assessment_update_column {
  """
  column name
  """
  company_id
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  difficulty
  """
  column name
  """
  id
  """
  column name
  """
  metadata
  """
  column name
  """
  title
  """
  column name
  """
  updated_at
}

"""
unique or primary key constraints on table "AssessmentCandidate"
"""
enum AssessmentCandidate_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  AssessmentCandidate_pkey
  """
  unique or primary key constraint on columns "assessment_id", "email"
  """
  CandidateEmailAssessment
}

"""
select columns of table "AssessmentCandidate"
"""
enum AssessmentCandidate_select_column {
  """
  column name
  """
  assessment_id
  """
  column name
  """
  created_at
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  status
}

"""
update columns of table "AssessmentCandidate"
"""
enum AssessmentCandidate_update_column {
  """
  column name
  """
  assessment_id
  """
  column name
  """
  created_at
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  status
}

"""
unique or primary key constraints on table "AssessmentCandidateAnswer"
"""
enum AssessmentCandidateAnswer_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  AssessmentCandidateAnswer_pkey
  """
  unique or primary key constraint on columns "question_id", "candidate_id"
  """
  CandidateQuestion
}

"""
select columns of table "AssessmentCandidateAnswer"
"""
enum AssessmentCandidateAnswer_select_column {
  """
  column name
  """
  activity_logs
  """
  column name
  """
  answer
  """
  column name
  """
  candidate_id
  """
  column name
  """
  created_at
  """
  column name
  """
  evaluated_at
  """
  column name
  """
  evaluation_details
  """
  column name
  """
  id
  """
  column name
  """
  question_id
  """
  column name
  """
  score
}

"""
update columns of table "AssessmentCandidateAnswer"
"""
enum AssessmentCandidateAnswer_update_column {
  """
  column name
  """
  activity_logs
  """
  column name
  """
  answer
  """
  column name
  """
  candidate_id
  """
  column name
  """
  created_at
  """
  column name
  """
  evaluated_at
  """
  column name
  """
  evaluation_details
  """
  column name
  """
  id
  """
  column name
  """
  question_id
  """
  column name
  """
  score
}

"""
unique or primary key constraints on table "AssessmentQuestion"
"""
enum AssessmentQuestion_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  AssessmentQuestion_pkey
}

"""
select columns of table "AssessmentQuestion"
"""
enum AssessmentQuestion_select_column {
  """
  column name
  """
  company_id
  """
  column name
  """
  config
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  difficulty
  """
  column name
  """
  duration
  """
  column name
  """
  id
  """
  column name
  """
  title
  """
  column name
  """
  type
  """
  column name
  """
  updated_at
}

"""
unique or primary key constraints on table "AssessmentQuestion_Skill"
"""
enum AssessmentQuestion_Skill_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  AssessmentQuestion_Skill_pkey
  """
  unique or primary key constraint on columns "question_id", "skill_id"
  """
  QuestionSkill
}

"""
select columns of table "AssessmentQuestion_Skill"
"""
enum AssessmentQuestion_Skill_select_column {
  """
  column name
  """
  id
  """
  column name
  """
  question_id
  """
  column name
  """
  skill_id
}

"""
update columns of table "AssessmentQuestion_Skill"
"""
enum AssessmentQuestion_Skill_update_column {
  """
  column name
  """
  id
  """
  column name
  """
  question_id
  """
  column name
  """
  skill_id
}

"""
update columns of table "AssessmentQuestion"
"""
enum AssessmentQuestion_update_column {
  """
  column name
  """
  company_id
  """
  column name
  """
  config
  """
  column name
  """
  created_at
  """
  column name
  """
  description
  """
  column name
  """
  difficulty
  """
  column name
  """
  duration
  """
  column name
  """
  id
  """
  column name
  """
  title
  """
  column name
  """
  type
  """
  column name
  """
  updated_at
}

"""
unique or primary key constraints on table "Candidate"
"""
enum Candidate_constraint {
  """
  unique or primary key constraint on columns "pipeline_id", "email"
  """
  CandidateEmailPipeline
  """
  unique or primary key constraint on columns "id"
  """
  Candidate_pkey
}

"""
select columns of table "Candidate"
"""
enum Candidate_select_column {
  """
  column name
  """
  application_metadata
  """
  column name
  """
  created_at
  """
  column name
  """
  current_node_id
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  pipeline_id
  """
  column name
  """
  resume_url
  """
  column name
  """
  status
  """
  column name
  """
  total_score
}

"""
select "Candidate_aggregate_bool_exp_avg_arguments_columns" columns of table "Candidate"
"""
enum Candidate_select_column_Candidate_aggregate_bool_exp_avg_arguments_columns {
  """
  column name
  """
  total_score
}

"""
select "Candidate_aggregate_bool_exp_corr_arguments_columns" columns of table "Candidate"
"""
enum Candidate_select_column_Candidate_aggregate_bool_exp_corr_arguments_columns {
  """
  column name
  """
  total_score
}

"""
select "Candidate_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "Candidate"
"""
enum Candidate_select_column_Candidate_aggregate_bool_exp_covar_samp_arguments_columns {
  """
  column name
  """
  total_score
}

"""
select "Candidate_aggregate_bool_exp_max_arguments_columns" columns of table "Candidate"
"""
enum Candidate_select_column_Candidate_aggregate_bool_exp_max_arguments_columns {
  """
  column name
  """
  total_score
}

"""
select "Candidate_aggregate_bool_exp_min_arguments_columns" columns of table "Candidate"
"""
enum Candidate_select_column_Candidate_aggregate_bool_exp_min_arguments_columns {
  """
  column name
  """
  total_score
}

"""
select "Candidate_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "Candidate"
"""
enum Candidate_select_column_Candidate_aggregate_bool_exp_stddev_samp_arguments_columns {
  """
  column name
  """
  total_score
}

"""
select "Candidate_aggregate_bool_exp_sum_arguments_columns" columns of table "Candidate"
"""
enum Candidate_select_column_Candidate_aggregate_bool_exp_sum_arguments_columns {
  """
  column name
  """
  total_score
}

"""
select "Candidate_aggregate_bool_exp_var_samp_arguments_columns" columns of table "Candidate"
"""
enum Candidate_select_column_Candidate_aggregate_bool_exp_var_samp_arguments_columns {
  """
  column name
  """
  total_score
}

"""
update columns of table "Candidate"
"""
enum Candidate_update_column {
  """
  column name
  """
  application_metadata
  """
  column name
  """
  created_at
  """
  column name
  """
  current_node_id
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  pipeline_id
  """
  column name
  """
  resume_url
  """
  column name
  """
  status
  """
  column name
  """
  total_score
}

"""
unique or primary key constraints on table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_constraint {
  """
  unique or primary key constraint on columns "node_id", "candidate_id"
  """
  CandidateNode
  """
  unique or primary key constraint on columns "id"
  """
  CandidateNodeResponse_pkey
}

"""
select columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column {
  """
  column name
  """
  candidate_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  node_id
  """
  column name
  """
  response
  """
  column name
  """
  result
  """
  column name
  """
  score
}

"""
select "CandidateNodeResponse_aggregate_bool_exp_avg_arguments_columns" columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_avg_arguments_columns {
  """
  column name
  """
  score
}

"""
select "CandidateNodeResponse_aggregate_bool_exp_corr_arguments_columns" columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_corr_arguments_columns {
  """
  column name
  """
  score
}

"""
select "CandidateNodeResponse_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_covar_samp_arguments_columns {
  """
  column name
  """
  score
}

"""
select "CandidateNodeResponse_aggregate_bool_exp_max_arguments_columns" columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_max_arguments_columns {
  """
  column name
  """
  score
}

"""
select "CandidateNodeResponse_aggregate_bool_exp_min_arguments_columns" columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_min_arguments_columns {
  """
  column name
  """
  score
}

"""
select "CandidateNodeResponse_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_stddev_samp_arguments_columns {
  """
  column name
  """
  score
}

"""
select "CandidateNodeResponse_aggregate_bool_exp_sum_arguments_columns" columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_sum_arguments_columns {
  """
  column name
  """
  score
}

"""
select "CandidateNodeResponse_aggregate_bool_exp_var_samp_arguments_columns" columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_var_samp_arguments_columns {
  """
  column name
  """
  score
}

"""
update columns of table "CandidateNodeResponse"
"""
enum CandidateNodeResponse_update_column {
  """
  column name
  """
  candidate_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  node_id
  """
  column name
  """
  response
  """
  column name
  """
  result
  """
  column name
  """
  score
}

"""
unique or primary key constraints on table "Company"
"""
enum Company_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Company_id_key
  """
  unique or primary key constraint on columns "id"
  """
  Company_pkey
  """
  unique or primary key constraint on columns "slug"
  """
  Company_slug_key
}

"""
select columns of table "Company"
"""
enum Company_select_column {
  """
  column name
  """
  ashby_api_key
  """
  column name
  """
  cover_url
  """
  column name
  """
  created_at
  """
  column name
  """
  credits
  """
  column name
  """
  display_assessment_score
  """
  column name
  """
  display_pipeline_info
  """
  column name
  """
  greenhouse_api_key
  """
  column name
  """
  id
  """
  column name
  """
  logo_url
  """
  column name
  """
  name
  """
  column name
  """
  slug
  """
  column name
  """
  zapier_access_token
}

"""
update columns of table "Company"
"""
enum Company_update_column {
  """
  column name
  """
  ashby_api_key
  """
  column name
  """
  cover_url
  """
  column name
  """
  created_at
  """
  column name
  """
  credits
  """
  column name
  """
  display_assessment_score
  """
  column name
  """
  display_pipeline_info
  """
  column name
  """
  greenhouse_api_key
  """
  column name
  """
  id
  """
  column name
  """
  logo_url
  """
  column name
  """
  name
  """
  column name
  """
  slug
  """
  column name
  """
  zapier_access_token
}

"""
unique or primary key constraints on table "Conversation"
"""
enum Conversation_constraint {
  """
  unique or primary key constraint on columns "company_id", "candidate_id"
  """
  Conversation_candidate_id_company_id_key
  """
  unique or primary key constraint on columns "id"
  """
  Conversation_pkey
}

"""
select columns of table "Conversation"
"""
enum Conversation_select_column {
  """
  column name
  """
  candidate_id
  """
  column name
  """
  company_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
}

"""
update columns of table "Conversation"
"""
enum Conversation_update_column {
  """
  column name
  """
  candidate_id
  """
  column name
  """
  company_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
}

"""
ordering argument of a cursor
"""
enum cursor_ordering {
  """
  ascending ordering of the cursor
  """
  ASC
  """
  descending ordering of the cursor
  """
  DESC
}

"""
unique or primary key constraints on table "Message"
"""
enum Message_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Message_pkey
}

"""
select columns of table "Message"
"""
enum Message_select_column {
  """
  column name
  """
  content
  """
  column name
  """
  conversation_id
  """
  column name
  """
  id
  """
  column name
  """
  sender_id
  """
  column name
  """
  sent_at
}

"""
update columns of table "Message"
"""
enum Message_update_column {
  """
  column name
  """
  content
  """
  column name
  """
  conversation_id
  """
  column name
  """
  id
  """
  column name
  """
  sender_id
  """
  column name
  """
  sent_at
}

"""
unique or primary key constraints on table "NodeLogs"
"""
enum NodeLogs_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  NodeLogs_pkey
}

"""
select columns of table "NodeLogs"
"""
enum NodeLogs_select_column {
  """
  column name
  """
  candidate_id
  """
  column name
  """
  created_at
  """
  column name
  """
  error_message
  """
  column name
  """
  id
  """
  column name
  """
  node_id
  """
  column name
  """
  notes
  """
  column name
  """
  status
  """
  column name
  """
  updated_at
}

"""
update columns of table "NodeLogs"
"""
enum NodeLogs_update_column {
  """
  column name
  """
  candidate_id
  """
  column name
  """
  created_at
  """
  column name
  """
  error_message
  """
  column name
  """
  id
  """
  column name
  """
  node_id
  """
  column name
  """
  notes
  """
  column name
  """
  status
  """
  column name
  """
  updated_at
}

"""
column ordering options
"""
enum order_by {
  """
  in ascending order, nulls last
  """
  asc
  """
  in ascending order, nulls first
  """
  asc_nulls_first
  """
  in ascending order, nulls last
  """
  asc_nulls_last
  """
  in descending order, nulls first
  """
  desc
  """
  in descending order, nulls first
  """
  desc_nulls_first
  """
  in descending order, nulls last
  """
  desc_nulls_last
}

"""
unique or primary key constraints on table "Pipeline"
"""
enum Pipeline_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Pipeline_pkey
}

"""
select columns of table "Pipeline"
"""
enum Pipeline_select_column {
  """
  column name
  """
  active
  """
  column name
  """
  company_id
  """
  column name
  """
  config
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  job_description
  """
  column name
  """
  job_title
  """
  column name
  """
  job_type
  """
  column name
  """
  location
  """
  column name
  """
  name
  """
  column name
  """
  node_flow
  """
  column name
  """
  updated_at
  """
  column name
  """
  workplace_type
}

"""
select "Pipeline_aggregate_bool_exp_bool_and_arguments_columns" columns of table "Pipeline"
"""
enum Pipeline_select_column_Pipeline_aggregate_bool_exp_bool_and_arguments_columns {
  """
  column name
  """
  active
}

"""
select "Pipeline_aggregate_bool_exp_bool_or_arguments_columns" columns of table "Pipeline"
"""
enum Pipeline_select_column_Pipeline_aggregate_bool_exp_bool_or_arguments_columns {
  """
  column name
  """
  active
}

"""
update columns of table "Pipeline"
"""
enum Pipeline_update_column {
  """
  column name
  """
  active
  """
  column name
  """
  company_id
  """
  column name
  """
  config
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  job_description
  """
  column name
  """
  job_title
  """
  column name
  """
  job_type
  """
  column name
  """
  location
  """
  column name
  """
  name
  """
  column name
  """
  node_flow
  """
  column name
  """
  updated_at
  """
  column name
  """
  workplace_type
}

"""
unique or primary key constraints on table "PipelineNode"
"""
enum PipelineNode_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PipelineNode_pkey
}

"""
select columns of table "PipelineNode"
"""
enum PipelineNode_select_column {
  """
  column name
  """
  id
  """
  column name
  """
  metadata
  """
  column name
  """
  node_flow_id
  """
  column name
  """
  pipeline_id
  """
  column name
  """
  type
}

"""
update columns of table "PipelineNode"
"""
enum PipelineNode_update_column {
  """
  column name
  """
  id
  """
  column name
  """
  metadata
  """
  column name
  """
  node_flow_id
  """
  column name
  """
  pipeline_id
  """
  column name
  """
  type
}

"""
unique or primary key constraints on table "Role"
"""
enum Role_constraint {
  """
  unique or primary key constraint on columns "label"
  """
  Role_label_key
  """
  unique or primary key constraint on columns "id"
  """
  Role_pkey
}

"""
select columns of table "Role"
"""
enum Role_select_column {
  """
  column name
  """
  id
  """
  column name
  """
  label
}

"""
update columns of table "Role"
"""
enum Role_update_column {
  """
  column name
  """
  id
  """
  column name
  """
  label
}

"""
unique or primary key constraints on table "Skill"
"""
enum Skill_constraint {
  """
  unique or primary key constraint on columns "label"
  """
  Skill_label_key
  """
  unique or primary key constraint on columns "id"
  """
  Skill_pkey
}

"""
unique or primary key constraints on table "Skill_Role"
"""
enum Skill_Role_constraint {
  """
  unique or primary key constraint on columns "role_id", "skill_id"
  """
  SkillRoleIndex
  """
  unique or primary key constraint on columns "id"
  """
  Skill_Role_pkey
}

"""
select columns of table "Skill_Role"
"""
enum Skill_Role_select_column {
  """
  column name
  """
  id
  """
  column name
  """
  role_id
  """
  column name
  """
  skill_id
}

"""
update columns of table "Skill_Role"
"""
enum Skill_Role_update_column {
  """
  column name
  """
  id
  """
  column name
  """
  role_id
  """
  column name
  """
  skill_id
}

"""
select columns of table "Skill"
"""
enum Skill_select_column {
  """
  column name
  """
  icon_svg
  """
  column name
  """
  id
  """
  column name
  """
  label
}

"""
update columns of table "Skill"
"""
enum Skill_update_column {
  """
  column name
  """
  icon_svg
  """
  column name
  """
  id
  """
  column name
  """
  label
}

"""
unique or primary key constraints on table "Transaction"
"""
enum Transaction_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Transaction_pkey
}

"""
select columns of table "Transaction"
"""
enum Transaction_select_column {
  """
  column name
  """
  amount
  """
  column name
  """
  company_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  type
}

"""
select "Transaction_aggregate_bool_exp_avg_arguments_columns" columns of table "Transaction"
"""
enum Transaction_select_column_Transaction_aggregate_bool_exp_avg_arguments_columns {
  """
  column name
  """
  amount
}

"""
select "Transaction_aggregate_bool_exp_corr_arguments_columns" columns of table "Transaction"
"""
enum Transaction_select_column_Transaction_aggregate_bool_exp_corr_arguments_columns {
  """
  column name
  """
  amount
}

"""
select "Transaction_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "Transaction"
"""
enum Transaction_select_column_Transaction_aggregate_bool_exp_covar_samp_arguments_columns {
  """
  column name
  """
  amount
}

"""
select "Transaction_aggregate_bool_exp_max_arguments_columns" columns of table "Transaction"
"""
enum Transaction_select_column_Transaction_aggregate_bool_exp_max_arguments_columns {
  """
  column name
  """
  amount
}

"""
select "Transaction_aggregate_bool_exp_min_arguments_columns" columns of table "Transaction"
"""
enum Transaction_select_column_Transaction_aggregate_bool_exp_min_arguments_columns {
  """
  column name
  """
  amount
}

"""
select "Transaction_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "Transaction"
"""
enum Transaction_select_column_Transaction_aggregate_bool_exp_stddev_samp_arguments_columns {
  """
  column name
  """
  amount
}

"""
select "Transaction_aggregate_bool_exp_sum_arguments_columns" columns of table "Transaction"
"""
enum Transaction_select_column_Transaction_aggregate_bool_exp_sum_arguments_columns {
  """
  column name
  """
  amount
}

"""
select "Transaction_aggregate_bool_exp_var_samp_arguments_columns" columns of table "Transaction"
"""
enum Transaction_select_column_Transaction_aggregate_bool_exp_var_samp_arguments_columns {
  """
  column name
  """
  amount
}

"""
update columns of table "Transaction"
"""
enum Transaction_update_column {
  """
  column name
  """
  amount
  """
  column name
  """
  company_id
  """
  column name
  """
  created_at
  """
  column name
  """
  id
  """
  column name
  """
  type
}

"""
unique or primary key constraints on table "User"
"""
enum User_constraint {
  """
  unique or primary key constraint on columns "email"
  """
  User_email_key
  """
  unique or primary key constraint on columns "id"
  """
  User_pkey
}

"""
select columns of table "User"
"""
enum User_select_column {
  """
  column name
  """
  company_id
  """
  column name
  """
  created_at
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  password_hash
  """
  column name
  """
  password_reset_token
  """
  column name
  """
  status
  """
  column name
  """
  updated_at
}

"""
update columns of table "User"
"""
enum User_update_column {
  """
  column name
  """
  company_id
  """
  column name
  """
  created_at
  """
  column name
  """
  email
  """
  column name
  """
  id
  """
  column name
  """
  name
  """
  column name
  """
  password_hash
  """
  column name
  """
  password_reset_token
  """
  column name
  """
  status
  """
  column name
  """
  updated_at
}

"""
columns and relationships of "Assessment"
"""
type Assessment {
  """
  An array relationship
  """
  Candidates(distinct_on: [AssessmentCandidate_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidate_order_by!], where: AssessmentCandidate_bool_exp): [AssessmentCandidate!]!
  """
  An aggregate relationship
  """
  Candidates_aggregate(distinct_on: [AssessmentCandidate_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidate_order_by!], where: AssessmentCandidate_bool_exp): AssessmentCandidate_aggregate!
  """
  An object relationship
  """
  Company: Company
  """
  An array relationship
  """
  Questions(distinct_on: [Assessment_AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [Assessment_AssessmentQuestion_order_by!], where: Assessment_AssessmentQuestion_bool_exp): [Assessment_AssessmentQuestion!]!
  """
  An aggregate relationship
  """
  Questions_aggregate(distinct_on: [Assessment_AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [Assessment_AssessmentQuestion_order_by!], where: Assessment_AssessmentQuestion_bool_exp): Assessment_AssessmentQuestion_aggregate!
  company_id: uuid
  created_at: timestamptz!
  description: String!
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String!
  id: uuid!
  metadata(path: String): jsonb!
  title: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "Assessment"
"""
type Assessment_aggregate {
  aggregate: Assessment_aggregate_fields
  nodes: [Assessment!]!
}

"""
aggregate fields of "Assessment"
"""
type Assessment_aggregate_fields {
  count(columns: [Assessment_select_column!], distinct: Boolean): Int!
  max: Assessment_max_fields
  min: Assessment_min_fields
}

"""
Associative Table for many-to-many relationship between Assessment and AssessmentQuestion
"""
type Assessment_AssessmentQuestion {
  """
  An object relationship
  """
  Assessment: Assessment!
  """
  An object relationship
  """
  Question: AssessmentQuestion!
  assessment_id: uuid!
  created_at: timestamptz!
  id: uuid!
  question_id: uuid!
}

"""
aggregated selection of "Assessment_AssessmentQuestion"
"""
type Assessment_AssessmentQuestion_aggregate {
  aggregate: Assessment_AssessmentQuestion_aggregate_fields
  nodes: [Assessment_AssessmentQuestion!]!
}

"""
aggregate fields of "Assessment_AssessmentQuestion"
"""
type Assessment_AssessmentQuestion_aggregate_fields {
  count(columns: [Assessment_AssessmentQuestion_select_column!], distinct: Boolean): Int!
  max: Assessment_AssessmentQuestion_max_fields
  min: Assessment_AssessmentQuestion_min_fields
}

"""
aggregate max on columns
"""
type Assessment_AssessmentQuestion_max_fields {
  assessment_id: uuid
  created_at: timestamptz
  id: uuid
  question_id: uuid
}

"""
aggregate min on columns
"""
type Assessment_AssessmentQuestion_min_fields {
  assessment_id: uuid
  created_at: timestamptz
  id: uuid
  question_id: uuid
}

"""
response of any mutation on the table "Assessment_AssessmentQuestion"
"""
type Assessment_AssessmentQuestion_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Assessment_AssessmentQuestion!]!
}

"""
aggregate max on columns
"""
type Assessment_max_fields {
  company_id: uuid
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  id: uuid
  title: String
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type Assessment_min_fields {
  company_id: uuid
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  id: uuid
  title: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "Assessment"
"""
type Assessment_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Assessment!]!
}

"""
columns and relationships of "AssessmentCandidate"
"""
type AssessmentCandidate {
  """
  An array relationship
  """
  Answers(distinct_on: [AssessmentCandidateAnswer_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidateAnswer_order_by!], where: AssessmentCandidateAnswer_bool_exp): [AssessmentCandidateAnswer!]!
  """
  An aggregate relationship
  """
  Answers_aggregate(distinct_on: [AssessmentCandidateAnswer_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidateAnswer_order_by!], where: AssessmentCandidateAnswer_bool_exp): AssessmentCandidateAnswer_aggregate!
  """
  An object relationship
  """
  Assessment: Assessment!
  assessment_id: uuid!
  created_at: timestamptz!
  email: String!
  id: uuid!
  name: String!
  status: String
}

"""
aggregated selection of "AssessmentCandidate"
"""
type AssessmentCandidate_aggregate {
  aggregate: AssessmentCandidate_aggregate_fields
  nodes: [AssessmentCandidate!]!
}

"""
aggregate fields of "AssessmentCandidate"
"""
type AssessmentCandidate_aggregate_fields {
  count(columns: [AssessmentCandidate_select_column!], distinct: Boolean): Int!
  max: AssessmentCandidate_max_fields
  min: AssessmentCandidate_min_fields
}

"""
aggregate max on columns
"""
type AssessmentCandidate_max_fields {
  assessment_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  status: String
}

"""
aggregate min on columns
"""
type AssessmentCandidate_min_fields {
  assessment_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  status: String
}

"""
response of any mutation on the table "AssessmentCandidate"
"""
type AssessmentCandidate_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [AssessmentCandidate!]!
}

"""
Stores the answers provided by candidates for each question in their assessment
"""
type AssessmentCandidateAnswer {
  """
  An object relationship
  """
  Candidate: AssessmentCandidate!
  """
  An object relationship
  """
  Question: AssessmentQuestion!
  activity_logs(path: String): jsonb
  answer(path: String): jsonb!
  candidate_id: uuid!
  created_at: timestamptz!
  evaluated_at: timestamptz
  evaluation_details(path: String): jsonb
  id: uuid!
  question_id: uuid!
  score: Int
}

"""
aggregated selection of "AssessmentCandidateAnswer"
"""
type AssessmentCandidateAnswer_aggregate {
  aggregate: AssessmentCandidateAnswer_aggregate_fields
  nodes: [AssessmentCandidateAnswer!]!
}

"""
aggregate fields of "AssessmentCandidateAnswer"
"""
type AssessmentCandidateAnswer_aggregate_fields {
  avg: AssessmentCandidateAnswer_avg_fields
  count(columns: [AssessmentCandidateAnswer_select_column!], distinct: Boolean): Int!
  max: AssessmentCandidateAnswer_max_fields
  min: AssessmentCandidateAnswer_min_fields
  stddev: AssessmentCandidateAnswer_stddev_fields
  stddev_pop: AssessmentCandidateAnswer_stddev_pop_fields
  stddev_samp: AssessmentCandidateAnswer_stddev_samp_fields
  sum: AssessmentCandidateAnswer_sum_fields
  var_pop: AssessmentCandidateAnswer_var_pop_fields
  var_samp: AssessmentCandidateAnswer_var_samp_fields
  variance: AssessmentCandidateAnswer_variance_fields
}

"""
aggregate avg on columns
"""
type AssessmentCandidateAnswer_avg_fields {
  score: Float
}

"""
aggregate max on columns
"""
type AssessmentCandidateAnswer_max_fields {
  candidate_id: uuid
  created_at: timestamptz
  evaluated_at: timestamptz
  id: uuid
  question_id: uuid
  score: Int
}

"""
aggregate min on columns
"""
type AssessmentCandidateAnswer_min_fields {
  candidate_id: uuid
  created_at: timestamptz
  evaluated_at: timestamptz
  id: uuid
  question_id: uuid
  score: Int
}

"""
response of any mutation on the table "AssessmentCandidateAnswer"
"""
type AssessmentCandidateAnswer_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [AssessmentCandidateAnswer!]!
}

"""
aggregate stddev on columns
"""
type AssessmentCandidateAnswer_stddev_fields {
  score: Float
}

"""
aggregate stddev_pop on columns
"""
type AssessmentCandidateAnswer_stddev_pop_fields {
  score: Float
}

"""
aggregate stddev_samp on columns
"""
type AssessmentCandidateAnswer_stddev_samp_fields {
  score: Float
}

"""
aggregate sum on columns
"""
type AssessmentCandidateAnswer_sum_fields {
  score: Int
}

"""
aggregate var_pop on columns
"""
type AssessmentCandidateAnswer_var_pop_fields {
  score: Float
}

"""
aggregate var_samp on columns
"""
type AssessmentCandidateAnswer_var_samp_fields {
  score: Float
}

"""
aggregate variance on columns
"""
type AssessmentCandidateAnswer_variance_fields {
  score: Float
}

"""
columns and relationships of "AssessmentQuestion"
"""
type AssessmentQuestion {
  """
  An array relationship
  """
  Assessments(distinct_on: [Assessment_AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [Assessment_AssessmentQuestion_order_by!], where: Assessment_AssessmentQuestion_bool_exp): [Assessment_AssessmentQuestion!]!
  """
  An aggregate relationship
  """
  Assessments_aggregate(distinct_on: [Assessment_AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [Assessment_AssessmentQuestion_order_by!], where: Assessment_AssessmentQuestion_bool_exp): Assessment_AssessmentQuestion_aggregate!
  """
  An object relationship
  """
  Company: Company
  """
  An array relationship
  """
  Skills(distinct_on: [AssessmentQuestion_Skill_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_Skill_order_by!], where: AssessmentQuestion_Skill_bool_exp): [AssessmentQuestion_Skill!]!
  """
  An aggregate relationship
  """
  Skills_aggregate(distinct_on: [AssessmentQuestion_Skill_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_Skill_order_by!], where: AssessmentQuestion_Skill_bool_exp): AssessmentQuestion_Skill_aggregate!
  company_id: uuid
  config(path: String): jsonb!
  created_at: timestamptz!
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String!
  duration: Int
  id: uuid!
  title: String!
  """
  Enum type: "Coding" | "Video" | "MCQ" | "OpenEnded" | "CodingRealtime" | "OpenEndedRealtime"
  """
  type: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "AssessmentQuestion"
"""
type AssessmentQuestion_aggregate {
  aggregate: AssessmentQuestion_aggregate_fields
  nodes: [AssessmentQuestion!]!
}

"""
aggregate fields of "AssessmentQuestion"
"""
type AssessmentQuestion_aggregate_fields {
  avg: AssessmentQuestion_avg_fields
  count(columns: [AssessmentQuestion_select_column!], distinct: Boolean): Int!
  max: AssessmentQuestion_max_fields
  min: AssessmentQuestion_min_fields
  stddev: AssessmentQuestion_stddev_fields
  stddev_pop: AssessmentQuestion_stddev_pop_fields
  stddev_samp: AssessmentQuestion_stddev_samp_fields
  sum: AssessmentQuestion_sum_fields
  var_pop: AssessmentQuestion_var_pop_fields
  var_samp: AssessmentQuestion_var_samp_fields
  variance: AssessmentQuestion_variance_fields
}

"""
aggregate avg on columns
"""
type AssessmentQuestion_avg_fields {
  duration: Float
}

"""
aggregate max on columns
"""
type AssessmentQuestion_max_fields {
  company_id: uuid
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  duration: Int
  id: uuid
  title: String
  """
  Enum type: "Coding" | "Video" | "MCQ" | "OpenEnded" | "CodingRealtime" | "OpenEndedRealtime"
  """
  type: String
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type AssessmentQuestion_min_fields {
  company_id: uuid
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  duration: Int
  id: uuid
  title: String
  """
  Enum type: "Coding" | "Video" | "MCQ" | "OpenEnded" | "CodingRealtime" | "OpenEndedRealtime"
  """
  type: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "AssessmentQuestion"
"""
type AssessmentQuestion_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [AssessmentQuestion!]!
}

"""
columns and relationships of "AssessmentQuestion_Skill"
"""
type AssessmentQuestion_Skill {
  """
  An object relationship
  """
  Question: AssessmentQuestion!
  """
  An object relationship
  """
  Skill: Skill!
  id: uuid!
  question_id: uuid!
  skill_id: uuid!
}

"""
aggregated selection of "AssessmentQuestion_Skill"
"""
type AssessmentQuestion_Skill_aggregate {
  aggregate: AssessmentQuestion_Skill_aggregate_fields
  nodes: [AssessmentQuestion_Skill!]!
}

"""
aggregate fields of "AssessmentQuestion_Skill"
"""
type AssessmentQuestion_Skill_aggregate_fields {
  count(columns: [AssessmentQuestion_Skill_select_column!], distinct: Boolean): Int!
  max: AssessmentQuestion_Skill_max_fields
  min: AssessmentQuestion_Skill_min_fields
}

"""
aggregate max on columns
"""
type AssessmentQuestion_Skill_max_fields {
  id: uuid
  question_id: uuid
  skill_id: uuid
}

"""
aggregate min on columns
"""
type AssessmentQuestion_Skill_min_fields {
  id: uuid
  question_id: uuid
  skill_id: uuid
}

"""
response of any mutation on the table "AssessmentQuestion_Skill"
"""
type AssessmentQuestion_Skill_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [AssessmentQuestion_Skill!]!
}

"""
aggregate stddev on columns
"""
type AssessmentQuestion_stddev_fields {
  duration: Float
}

"""
aggregate stddev_pop on columns
"""
type AssessmentQuestion_stddev_pop_fields {
  duration: Float
}

"""
aggregate stddev_samp on columns
"""
type AssessmentQuestion_stddev_samp_fields {
  duration: Float
}

"""
aggregate sum on columns
"""
type AssessmentQuestion_sum_fields {
  duration: Int
}

"""
aggregate var_pop on columns
"""
type AssessmentQuestion_var_pop_fields {
  duration: Float
}

"""
aggregate var_samp on columns
"""
type AssessmentQuestion_var_samp_fields {
  duration: Float
}

"""
aggregate variance on columns
"""
type AssessmentQuestion_variance_fields {
  duration: Float
}

"""
Candidates in a Pipeline
"""
type Candidate {
  """
  An array relationship
  """
  Conversations(distinct_on: [Conversation_select_column!], limit: Int, offset: Int, order_by: [Conversation_order_by!], where: Conversation_bool_exp): [Conversation!]!
  """
  An aggregate relationship
  """
  Conversations_aggregate(distinct_on: [Conversation_select_column!], limit: Int, offset: Int, order_by: [Conversation_order_by!], where: Conversation_bool_exp): Conversation_aggregate!
  """
  An object relationship
  """
  CurrentNode: PipelineNode
  """
  An array relationship
  """
  NodeResponses(distinct_on: [CandidateNodeResponse_select_column!], limit: Int, offset: Int, order_by: [CandidateNodeResponse_order_by!], where: CandidateNodeResponse_bool_exp): [CandidateNodeResponse!]!
  """
  An aggregate relationship
  """
  NodeResponses_aggregate(distinct_on: [CandidateNodeResponse_select_column!], limit: Int, offset: Int, order_by: [CandidateNodeResponse_order_by!], where: CandidateNodeResponse_bool_exp): CandidateNodeResponse_aggregate!
  """
  An object relationship
  """
  Pipeline: Pipeline!
  application_metadata(path: String): jsonb!
  created_at: timestamptz!
  current_node_id: uuid
  email: String!
  id: uuid!
  name: String!
  pipeline_id: uuid!
  resume_url: String!
  status: String!
  total_score: float8
}

"""
aggregated selection of "Candidate"
"""
type Candidate_aggregate {
  aggregate: Candidate_aggregate_fields
  nodes: [Candidate!]!
}

"""
aggregate fields of "Candidate"
"""
type Candidate_aggregate_fields {
  avg: Candidate_avg_fields
  count(columns: [Candidate_select_column!], distinct: Boolean): Int!
  max: Candidate_max_fields
  min: Candidate_min_fields
  stddev: Candidate_stddev_fields
  stddev_pop: Candidate_stddev_pop_fields
  stddev_samp: Candidate_stddev_samp_fields
  sum: Candidate_sum_fields
  var_pop: Candidate_var_pop_fields
  var_samp: Candidate_var_samp_fields
  variance: Candidate_variance_fields
}

"""
aggregate avg on columns
"""
type Candidate_avg_fields {
  total_score: Float
}

"""
aggregate max on columns
"""
type Candidate_max_fields {
  created_at: timestamptz
  current_node_id: uuid
  email: String
  id: uuid
  name: String
  pipeline_id: uuid
  resume_url: String
  status: String
  total_score: float8
}

"""
aggregate min on columns
"""
type Candidate_min_fields {
  created_at: timestamptz
  current_node_id: uuid
  email: String
  id: uuid
  name: String
  pipeline_id: uuid
  resume_url: String
  status: String
  total_score: float8
}

"""
response of any mutation on the table "Candidate"
"""
type Candidate_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Candidate!]!
}

"""
aggregate stddev on columns
"""
type Candidate_stddev_fields {
  total_score: Float
}

"""
aggregate stddev_pop on columns
"""
type Candidate_stddev_pop_fields {
  total_score: Float
}

"""
aggregate stddev_samp on columns
"""
type Candidate_stddev_samp_fields {
  total_score: Float
}

"""
aggregate sum on columns
"""
type Candidate_sum_fields {
  total_score: float8
}

"""
aggregate var_pop on columns
"""
type Candidate_var_pop_fields {
  total_score: Float
}

"""
aggregate var_samp on columns
"""
type Candidate_var_samp_fields {
  total_score: Float
}

"""
aggregate variance on columns
"""
type Candidate_variance_fields {
  total_score: Float
}

"""
Node responses from Candidates
"""
type CandidateNodeResponse {
  """
  An object relationship
  """
  Candidate: Candidate!
  """
  An object relationship
  """
  PipelineNode: PipelineNode!
  candidate_id: uuid!
  created_at: timestamptz!
  id: uuid!
  node_id: uuid!
  response(path: String): jsonb!
  result(path: String): jsonb
  score: float8
}

"""
aggregated selection of "CandidateNodeResponse"
"""
type CandidateNodeResponse_aggregate {
  aggregate: CandidateNodeResponse_aggregate_fields
  nodes: [CandidateNodeResponse!]!
}

"""
aggregate fields of "CandidateNodeResponse"
"""
type CandidateNodeResponse_aggregate_fields {
  avg: CandidateNodeResponse_avg_fields
  count(columns: [CandidateNodeResponse_select_column!], distinct: Boolean): Int!
  max: CandidateNodeResponse_max_fields
  min: CandidateNodeResponse_min_fields
  stddev: CandidateNodeResponse_stddev_fields
  stddev_pop: CandidateNodeResponse_stddev_pop_fields
  stddev_samp: CandidateNodeResponse_stddev_samp_fields
  sum: CandidateNodeResponse_sum_fields
  var_pop: CandidateNodeResponse_var_pop_fields
  var_samp: CandidateNodeResponse_var_samp_fields
  variance: CandidateNodeResponse_variance_fields
}

"""
aggregate avg on columns
"""
type CandidateNodeResponse_avg_fields {
  score: Float
}

"""
aggregate max on columns
"""
type CandidateNodeResponse_max_fields {
  candidate_id: uuid
  created_at: timestamptz
  id: uuid
  node_id: uuid
  score: float8
}

"""
aggregate min on columns
"""
type CandidateNodeResponse_min_fields {
  candidate_id: uuid
  created_at: timestamptz
  id: uuid
  node_id: uuid
  score: float8
}

"""
response of any mutation on the table "CandidateNodeResponse"
"""
type CandidateNodeResponse_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [CandidateNodeResponse!]!
}

"""
aggregate stddev on columns
"""
type CandidateNodeResponse_stddev_fields {
  score: Float
}

"""
aggregate stddev_pop on columns
"""
type CandidateNodeResponse_stddev_pop_fields {
  score: Float
}

"""
aggregate stddev_samp on columns
"""
type CandidateNodeResponse_stddev_samp_fields {
  score: Float
}

"""
aggregate sum on columns
"""
type CandidateNodeResponse_sum_fields {
  score: float8
}

"""
aggregate var_pop on columns
"""
type CandidateNodeResponse_var_pop_fields {
  score: Float
}

"""
aggregate var_samp on columns
"""
type CandidateNodeResponse_var_samp_fields {
  score: Float
}

"""
aggregate variance on columns
"""
type CandidateNodeResponse_variance_fields {
  score: Float
}

type CheckoutSessionOutput {
  sessionUrl: String
  success: Boolean
}

"""
columns and relationships of "Company"
"""
type Company {
  """
  An array relationship
  """
  Assessments(distinct_on: [Assessment_select_column!], limit: Int, offset: Int, order_by: [Assessment_order_by!], where: Assessment_bool_exp): [Assessment!]!
  """
  An aggregate relationship
  """
  Assessments_aggregate(distinct_on: [Assessment_select_column!], limit: Int, offset: Int, order_by: [Assessment_order_by!], where: Assessment_bool_exp): Assessment_aggregate!
  """
  An array relationship
  """
  Conversations(distinct_on: [Conversation_select_column!], limit: Int, offset: Int, order_by: [Conversation_order_by!], where: Conversation_bool_exp): [Conversation!]!
  """
  An aggregate relationship
  """
  Conversations_aggregate(distinct_on: [Conversation_select_column!], limit: Int, offset: Int, order_by: [Conversation_order_by!], where: Conversation_bool_exp): Conversation_aggregate!
  """
  An array relationship
  """
  Members(distinct_on: [User_select_column!], limit: Int, offset: Int, order_by: [User_order_by!], where: User_bool_exp): [User!]!
  """
  An aggregate relationship
  """
  Members_aggregate(distinct_on: [User_select_column!], limit: Int, offset: Int, order_by: [User_order_by!], where: User_bool_exp): User_aggregate!
  """
  An array relationship
  """
  Pipelines(distinct_on: [Pipeline_select_column!], limit: Int, offset: Int, order_by: [Pipeline_order_by!], where: Pipeline_bool_exp): [Pipeline!]!
  """
  An aggregate relationship
  """
  Pipelines_aggregate(distinct_on: [Pipeline_select_column!], limit: Int, offset: Int, order_by: [Pipeline_order_by!], where: Pipeline_bool_exp): Pipeline_aggregate!
  """
  An array relationship
  """
  Transactions(distinct_on: [Transaction_select_column!], limit: Int, offset: Int, order_by: [Transaction_order_by!], where: Transaction_bool_exp): [Transaction!]!
  """
  An aggregate relationship
  """
  Transactions_aggregate(distinct_on: [Transaction_select_column!], limit: Int, offset: Int, order_by: [Transaction_order_by!], where: Transaction_bool_exp): Transaction_aggregate!
  ashby_api_key: String
  cover_url: String
  created_at: timestamptz!
  credits: float8!
  display_assessment_score: Boolean!
  display_pipeline_info: Boolean!
  greenhouse_api_key: String
  id: uuid!
  logo_url: String
  name: String!
  slug: String!
  zapier_access_token: String
}

"""
aggregated selection of "Company"
"""
type Company_aggregate {
  aggregate: Company_aggregate_fields
  nodes: [Company!]!
}

"""
aggregate fields of "Company"
"""
type Company_aggregate_fields {
  avg: Company_avg_fields
  count(columns: [Company_select_column!], distinct: Boolean): Int!
  max: Company_max_fields
  min: Company_min_fields
  stddev: Company_stddev_fields
  stddev_pop: Company_stddev_pop_fields
  stddev_samp: Company_stddev_samp_fields
  sum: Company_sum_fields
  var_pop: Company_var_pop_fields
  var_samp: Company_var_samp_fields
  variance: Company_variance_fields
}

"""
aggregate avg on columns
"""
type Company_avg_fields {
  credits: Float
}

"""
aggregate max on columns
"""
type Company_max_fields {
  ashby_api_key: String
  cover_url: String
  created_at: timestamptz
  credits: float8
  greenhouse_api_key: String
  id: uuid
  logo_url: String
  name: String
  slug: String
  zapier_access_token: String
}

"""
aggregate min on columns
"""
type Company_min_fields {
  ashby_api_key: String
  cover_url: String
  created_at: timestamptz
  credits: float8
  greenhouse_api_key: String
  id: uuid
  logo_url: String
  name: String
  slug: String
  zapier_access_token: String
}

"""
response of any mutation on the table "Company"
"""
type Company_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Company!]!
}

"""
aggregate stddev on columns
"""
type Company_stddev_fields {
  credits: Float
}

"""
aggregate stddev_pop on columns
"""
type Company_stddev_pop_fields {
  credits: Float
}

"""
aggregate stddev_samp on columns
"""
type Company_stddev_samp_fields {
  credits: Float
}

"""
aggregate sum on columns
"""
type Company_sum_fields {
  credits: float8
}

"""
aggregate var_pop on columns
"""
type Company_var_pop_fields {
  credits: Float
}

"""
aggregate var_samp on columns
"""
type Company_var_samp_fields {
  credits: Float
}

"""
aggregate variance on columns
"""
type Company_variance_fields {
  credits: Float
}

"""
columns and relationships of "Conversation"
"""
type Conversation {
  """
  An object relationship
  """
  Candidate: Candidate!
  """
  An object relationship
  """
  Company: Company!
  """
  An array relationship
  """
  Messages(distinct_on: [Message_select_column!], limit: Int, offset: Int, order_by: [Message_order_by!], where: Message_bool_exp): [Message!]!
  """
  An aggregate relationship
  """
  Messages_aggregate(distinct_on: [Message_select_column!], limit: Int, offset: Int, order_by: [Message_order_by!], where: Message_bool_exp): Message_aggregate!
  candidate_id: uuid!
  company_id: uuid!
  created_at: timestamptz!
  id: uuid!
}

"""
aggregated selection of "Conversation"
"""
type Conversation_aggregate {
  aggregate: Conversation_aggregate_fields
  nodes: [Conversation!]!
}

"""
aggregate fields of "Conversation"
"""
type Conversation_aggregate_fields {
  count(columns: [Conversation_select_column!], distinct: Boolean): Int!
  max: Conversation_max_fields
  min: Conversation_min_fields
}

"""
aggregate max on columns
"""
type Conversation_max_fields {
  candidate_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
}

"""
aggregate min on columns
"""
type Conversation_min_fields {
  candidate_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
}

"""
response of any mutation on the table "Conversation"
"""
type Conversation_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Conversation!]!
}

type GeneratePipelineOutput {
  id: String!
  message: String!
}

"""
columns and relationships of "Message"
"""
type Message {
  content: String!
  conversation_id: uuid!
  id: uuid!
  sender_id: uuid!
  sent_at: timestamptz!
}

"""
aggregated selection of "Message"
"""
type Message_aggregate {
  aggregate: Message_aggregate_fields
  nodes: [Message!]!
}

"""
aggregate fields of "Message"
"""
type Message_aggregate_fields {
  count(columns: [Message_select_column!], distinct: Boolean): Int!
  max: Message_max_fields
  min: Message_min_fields
}

"""
aggregate max on columns
"""
type Message_max_fields {
  content: String
  conversation_id: uuid
  id: uuid
  sender_id: uuid
  sent_at: timestamptz
}

"""
aggregate min on columns
"""
type Message_min_fields {
  content: String
  conversation_id: uuid
  id: uuid
  sender_id: uuid
  sent_at: timestamptz
}

"""
response of any mutation on the table "Message"
"""
type Message_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Message!]!
}

"""
mutation root
"""
type mutation_root {
  changePassword(input: ChangePasswordInput!): ResponsePayload!
  """
  Create stripe checkout session action
  """
  createCheckoutSession(arg: CheckoutSessionInput!): CheckoutSessionOutput
  """
  Create Question Action
  """
  createQuestion(arg: jsonb!): ResponseStatus
  """
  delete data from the table: "Assessment"
  """
  delete_Assessment(where: Assessment_bool_exp!): Assessment_mutation_response
  """
  delete data from the table: "AssessmentCandidate"
  """
  delete_AssessmentCandidate(where: AssessmentCandidate_bool_exp!): AssessmentCandidate_mutation_response
  """
  delete data from the table: "AssessmentCandidateAnswer"
  """
  delete_AssessmentCandidateAnswer(where: AssessmentCandidateAnswer_bool_exp!): AssessmentCandidateAnswer_mutation_response
  """
  delete single row from the table: "AssessmentCandidateAnswer"
  """
  delete_AssessmentCandidateAnswer_by_pk(id: uuid!): AssessmentCandidateAnswer
  """
  delete single row from the table: "AssessmentCandidate"
  """
  delete_AssessmentCandidate_by_pk(id: uuid!): AssessmentCandidate
  """
  delete data from the table: "AssessmentQuestion"
  """
  delete_AssessmentQuestion(where: AssessmentQuestion_bool_exp!): AssessmentQuestion_mutation_response
  """
  delete data from the table: "AssessmentQuestion_Skill"
  """
  delete_AssessmentQuestion_Skill(where: AssessmentQuestion_Skill_bool_exp!): AssessmentQuestion_Skill_mutation_response
  """
  delete single row from the table: "AssessmentQuestion_Skill"
  """
  delete_AssessmentQuestion_Skill_by_pk(id: uuid!): AssessmentQuestion_Skill
  """
  delete single row from the table: "AssessmentQuestion"
  """
  delete_AssessmentQuestion_by_pk(id: uuid!): AssessmentQuestion
  """
  delete data from the table: "Assessment_AssessmentQuestion"
  """
  delete_Assessment_AssessmentQuestion(where: Assessment_AssessmentQuestion_bool_exp!): Assessment_AssessmentQuestion_mutation_response
  """
  delete single row from the table: "Assessment_AssessmentQuestion"
  """
  delete_Assessment_AssessmentQuestion_by_pk(id: uuid!): Assessment_AssessmentQuestion
  """
  delete single row from the table: "Assessment"
  """
  delete_Assessment_by_pk(id: uuid!): Assessment
  """
  delete data from the table: "Candidate"
  """
  delete_Candidate(where: Candidate_bool_exp!): Candidate_mutation_response
  """
  delete data from the table: "CandidateNodeResponse"
  """
  delete_CandidateNodeResponse(where: CandidateNodeResponse_bool_exp!): CandidateNodeResponse_mutation_response
  """
  delete single row from the table: "CandidateNodeResponse"
  """
  delete_CandidateNodeResponse_by_pk(id: uuid!): CandidateNodeResponse
  """
  delete single row from the table: "Candidate"
  """
  delete_Candidate_by_pk(id: uuid!): Candidate
  """
  delete data from the table: "Company"
  """
  delete_Company(where: Company_bool_exp!): Company_mutation_response
  """
  delete single row from the table: "Company"
  """
  delete_Company_by_pk(id: uuid!): Company
  """
  delete data from the table: "Conversation"
  """
  delete_Conversation(where: Conversation_bool_exp!): Conversation_mutation_response
  """
  delete single row from the table: "Conversation"
  """
  delete_Conversation_by_pk(id: uuid!): Conversation
  """
  delete data from the table: "Message"
  """
  delete_Message(where: Message_bool_exp!): Message_mutation_response
  """
  delete single row from the table: "Message"
  """
  delete_Message_by_pk(id: uuid!): Message
  """
  delete data from the table: "NodeLogs"
  """
  delete_NodeLogs(where: NodeLogs_bool_exp!): NodeLogs_mutation_response
  """
  delete single row from the table: "NodeLogs"
  """
  delete_NodeLogs_by_pk(id: uuid!): NodeLogs
  """
  delete data from the table: "Pipeline"
  """
  delete_Pipeline(where: Pipeline_bool_exp!): Pipeline_mutation_response
  """
  delete data from the table: "PipelineNode"
  """
  delete_PipelineNode(where: PipelineNode_bool_exp!): PipelineNode_mutation_response
  """
  delete single row from the table: "PipelineNode"
  """
  delete_PipelineNode_by_pk(id: uuid!): PipelineNode
  """
  delete single row from the table: "Pipeline"
  """
  delete_Pipeline_by_pk(id: uuid!): Pipeline
  """
  delete data from the table: "Role"
  """
  delete_Role(where: Role_bool_exp!): Role_mutation_response
  """
  delete single row from the table: "Role"
  """
  delete_Role_by_pk(id: uuid!): Role
  """
  delete data from the table: "Skill"
  """
  delete_Skill(where: Skill_bool_exp!): Skill_mutation_response
  """
  delete data from the table: "Skill_Role"
  """
  delete_Skill_Role(where: Skill_Role_bool_exp!): Skill_Role_mutation_response
  """
  delete single row from the table: "Skill_Role"
  """
  delete_Skill_Role_by_pk(id: uuid!): Skill_Role
  """
  delete single row from the table: "Skill"
  """
  delete_Skill_by_pk(id: uuid!): Skill
  """
  delete data from the table: "Transaction"
  """
  delete_Transaction(where: Transaction_bool_exp!): Transaction_mutation_response
  """
  delete single row from the table: "Transaction"
  """
  delete_Transaction_by_pk(id: uuid!): Transaction
  """
  delete data from the table: "User"
  """
  delete_User(where: User_bool_exp!): User_mutation_response
  """
  delete single row from the table: "User"
  """
  delete_User_by_pk(id: uuid!): User
  forgotPassword(input: ForgotPasswordInput!): ResponsePayload!
  """
  Generate Custom Pipeline action
  """
  generatePipeline(arg: GeneratePipelineInput!): GeneratePipelineOutput!
  """
  Auth User With Google Oauth
  """
  googleAuth(input: GoogleAuthInput!): ResponsePayload!
  """
  insert data into the table: "Assessment"
  """
  insert_Assessment(objects: [Assessment_insert_input!]!, on_conflict: Assessment_on_conflict): Assessment_mutation_response
  """
  insert data into the table: "AssessmentCandidate"
  """
  insert_AssessmentCandidate(objects: [AssessmentCandidate_insert_input!]!, on_conflict: AssessmentCandidate_on_conflict): AssessmentCandidate_mutation_response
  """
  insert data into the table: "AssessmentCandidateAnswer"
  """
  insert_AssessmentCandidateAnswer(objects: [AssessmentCandidateAnswer_insert_input!]!, on_conflict: AssessmentCandidateAnswer_on_conflict): AssessmentCandidateAnswer_mutation_response
  """
  insert a single row into the table: "AssessmentCandidateAnswer"
  """
  insert_AssessmentCandidateAnswer_one(object: AssessmentCandidateAnswer_insert_input!, on_conflict: AssessmentCandidateAnswer_on_conflict): AssessmentCandidateAnswer
  """
  insert a single row into the table: "AssessmentCandidate"
  """
  insert_AssessmentCandidate_one(object: AssessmentCandidate_insert_input!, on_conflict: AssessmentCandidate_on_conflict): AssessmentCandidate
  """
  insert data into the table: "AssessmentQuestion"
  """
  insert_AssessmentQuestion(objects: [AssessmentQuestion_insert_input!]!, on_conflict: AssessmentQuestion_on_conflict): AssessmentQuestion_mutation_response
  """
  insert data into the table: "AssessmentQuestion_Skill"
  """
  insert_AssessmentQuestion_Skill(objects: [AssessmentQuestion_Skill_insert_input!]!, on_conflict: AssessmentQuestion_Skill_on_conflict): AssessmentQuestion_Skill_mutation_response
  """
  insert a single row into the table: "AssessmentQuestion_Skill"
  """
  insert_AssessmentQuestion_Skill_one(object: AssessmentQuestion_Skill_insert_input!, on_conflict: AssessmentQuestion_Skill_on_conflict): AssessmentQuestion_Skill
  """
  insert a single row into the table: "AssessmentQuestion"
  """
  insert_AssessmentQuestion_one(object: AssessmentQuestion_insert_input!, on_conflict: AssessmentQuestion_on_conflict): AssessmentQuestion
  """
  insert data into the table: "Assessment_AssessmentQuestion"
  """
  insert_Assessment_AssessmentQuestion(objects: [Assessment_AssessmentQuestion_insert_input!]!, on_conflict: Assessment_AssessmentQuestion_on_conflict): Assessment_AssessmentQuestion_mutation_response
  """
  insert a single row into the table: "Assessment_AssessmentQuestion"
  """
  insert_Assessment_AssessmentQuestion_one(object: Assessment_AssessmentQuestion_insert_input!, on_conflict: Assessment_AssessmentQuestion_on_conflict): Assessment_AssessmentQuestion
  """
  insert a single row into the table: "Assessment"
  """
  insert_Assessment_one(object: Assessment_insert_input!, on_conflict: Assessment_on_conflict): Assessment
  """
  insert data into the table: "Candidate"
  """
  insert_Candidate(objects: [Candidate_insert_input!]!, on_conflict: Candidate_on_conflict): Candidate_mutation_response
  """
  insert data into the table: "CandidateNodeResponse"
  """
  insert_CandidateNodeResponse(objects: [CandidateNodeResponse_insert_input!]!, on_conflict: CandidateNodeResponse_on_conflict): CandidateNodeResponse_mutation_response
  """
  insert a single row into the table: "CandidateNodeResponse"
  """
  insert_CandidateNodeResponse_one(object: CandidateNodeResponse_insert_input!, on_conflict: CandidateNodeResponse_on_conflict): CandidateNodeResponse
  """
  insert a single row into the table: "Candidate"
  """
  insert_Candidate_one(object: Candidate_insert_input!, on_conflict: Candidate_on_conflict): Candidate
  """
  insert data into the table: "Company"
  """
  insert_Company(objects: [Company_insert_input!]!, on_conflict: Company_on_conflict): Company_mutation_response
  """
  insert a single row into the table: "Company"
  """
  insert_Company_one(object: Company_insert_input!, on_conflict: Company_on_conflict): Company
  """
  insert data into the table: "Conversation"
  """
  insert_Conversation(objects: [Conversation_insert_input!]!, on_conflict: Conversation_on_conflict): Conversation_mutation_response
  """
  insert a single row into the table: "Conversation"
  """
  insert_Conversation_one(object: Conversation_insert_input!, on_conflict: Conversation_on_conflict): Conversation
  """
  insert data into the table: "Message"
  """
  insert_Message(objects: [Message_insert_input!]!, on_conflict: Message_on_conflict): Message_mutation_response
  """
  insert a single row into the table: "Message"
  """
  insert_Message_one(object: Message_insert_input!, on_conflict: Message_on_conflict): Message
  """
  insert data into the table: "NodeLogs"
  """
  insert_NodeLogs(objects: [NodeLogs_insert_input!]!, on_conflict: NodeLogs_on_conflict): NodeLogs_mutation_response
  """
  insert a single row into the table: "NodeLogs"
  """
  insert_NodeLogs_one(object: NodeLogs_insert_input!, on_conflict: NodeLogs_on_conflict): NodeLogs
  """
  insert data into the table: "Pipeline"
  """
  insert_Pipeline(objects: [Pipeline_insert_input!]!, on_conflict: Pipeline_on_conflict): Pipeline_mutation_response
  """
  insert data into the table: "PipelineNode"
  """
  insert_PipelineNode(objects: [PipelineNode_insert_input!]!, on_conflict: PipelineNode_on_conflict): PipelineNode_mutation_response
  """
  insert a single row into the table: "PipelineNode"
  """
  insert_PipelineNode_one(object: PipelineNode_insert_input!, on_conflict: PipelineNode_on_conflict): PipelineNode
  """
  insert a single row into the table: "Pipeline"
  """
  insert_Pipeline_one(object: Pipeline_insert_input!, on_conflict: Pipeline_on_conflict): Pipeline
  """
  insert data into the table: "Role"
  """
  insert_Role(objects: [Role_insert_input!]!, on_conflict: Role_on_conflict): Role_mutation_response
  """
  insert a single row into the table: "Role"
  """
  insert_Role_one(object: Role_insert_input!, on_conflict: Role_on_conflict): Role
  """
  insert data into the table: "Skill"
  """
  insert_Skill(objects: [Skill_insert_input!]!, on_conflict: Skill_on_conflict): Skill_mutation_response
  """
  insert data into the table: "Skill_Role"
  """
  insert_Skill_Role(objects: [Skill_Role_insert_input!]!, on_conflict: Skill_Role_on_conflict): Skill_Role_mutation_response
  """
  insert a single row into the table: "Skill_Role"
  """
  insert_Skill_Role_one(object: Skill_Role_insert_input!, on_conflict: Skill_Role_on_conflict): Skill_Role
  """
  insert a single row into the table: "Skill"
  """
  insert_Skill_one(object: Skill_insert_input!, on_conflict: Skill_on_conflict): Skill
  """
  insert data into the table: "Transaction"
  """
  insert_Transaction(objects: [Transaction_insert_input!]!, on_conflict: Transaction_on_conflict): Transaction_mutation_response
  """
  insert a single row into the table: "Transaction"
  """
  insert_Transaction_one(object: Transaction_insert_input!, on_conflict: Transaction_on_conflict): Transaction
  """
  insert data into the table: "User"
  """
  insert_User(objects: [User_insert_input!]!, on_conflict: User_on_conflict): User_mutation_response
  """
  insert a single row into the table: "User"
  """
  insert_User_one(object: User_insert_input!, on_conflict: User_on_conflict): User
  """
  Invite a company member
  """
  inviteCompanyMember(arg: InviteCompanyMemberInput!): ResponseStatus!
  """
  Login users action
  """
  login(arg: LoginInput!): ResponsePayload!
  """
  Register a new user action
  """
  registerUser(arg: RegisterUserInput!): ResponsePayload!
  resetPassword(input: ResetPasswordInput!): ResponsePayload!
  """
  Update Question Action
  """
  updateQuestion(arg: jsonb!): ResponseStatus
  """
  update data of the table: "Assessment"
  """
  update_Assessment(_append: Assessment_append_input, _delete_at_path: Assessment_delete_at_path_input, _delete_elem: Assessment_delete_elem_input, _delete_key: Assessment_delete_key_input, _prepend: Assessment_prepend_input, _set: Assessment_set_input, where: Assessment_bool_exp!): Assessment_mutation_response
  """
  update data of the table: "AssessmentCandidate"
  """
  update_AssessmentCandidate(_set: AssessmentCandidate_set_input, where: AssessmentCandidate_bool_exp!): AssessmentCandidate_mutation_response
  """
  update data of the table: "AssessmentCandidateAnswer"
  """
  update_AssessmentCandidateAnswer(_append: AssessmentCandidateAnswer_append_input, _delete_at_path: AssessmentCandidateAnswer_delete_at_path_input, _delete_elem: AssessmentCandidateAnswer_delete_elem_input, _delete_key: AssessmentCandidateAnswer_delete_key_input, _inc: AssessmentCandidateAnswer_inc_input, _prepend: AssessmentCandidateAnswer_prepend_input, _set: AssessmentCandidateAnswer_set_input, where: AssessmentCandidateAnswer_bool_exp!): AssessmentCandidateAnswer_mutation_response
  """
  update single row of the table: "AssessmentCandidateAnswer"
  """
  update_AssessmentCandidateAnswer_by_pk(_append: AssessmentCandidateAnswer_append_input, _delete_at_path: AssessmentCandidateAnswer_delete_at_path_input, _delete_elem: AssessmentCandidateAnswer_delete_elem_input, _delete_key: AssessmentCandidateAnswer_delete_key_input, _inc: AssessmentCandidateAnswer_inc_input, _prepend: AssessmentCandidateAnswer_prepend_input, _set: AssessmentCandidateAnswer_set_input, pk_columns: AssessmentCandidateAnswer_pk_columns_input!): AssessmentCandidateAnswer
  """
  update multiples rows of table: "AssessmentCandidateAnswer"
  """
  update_AssessmentCandidateAnswer_many(updates: [AssessmentCandidateAnswer_updates!]!): [AssessmentCandidateAnswer_mutation_response]
  """
  update single row of the table: "AssessmentCandidate"
  """
  update_AssessmentCandidate_by_pk(_set: AssessmentCandidate_set_input, pk_columns: AssessmentCandidate_pk_columns_input!): AssessmentCandidate
  """
  update multiples rows of table: "AssessmentCandidate"
  """
  update_AssessmentCandidate_many(updates: [AssessmentCandidate_updates!]!): [AssessmentCandidate_mutation_response]
  """
  update data of the table: "AssessmentQuestion"
  """
  update_AssessmentQuestion(_append: AssessmentQuestion_append_input, _delete_at_path: AssessmentQuestion_delete_at_path_input, _delete_elem: AssessmentQuestion_delete_elem_input, _delete_key: AssessmentQuestion_delete_key_input, _inc: AssessmentQuestion_inc_input, _prepend: AssessmentQuestion_prepend_input, _set: AssessmentQuestion_set_input, where: AssessmentQuestion_bool_exp!): AssessmentQuestion_mutation_response
  """
  update data of the table: "AssessmentQuestion_Skill"
  """
  update_AssessmentQuestion_Skill(_set: AssessmentQuestion_Skill_set_input, where: AssessmentQuestion_Skill_bool_exp!): AssessmentQuestion_Skill_mutation_response
  """
  update single row of the table: "AssessmentQuestion_Skill"
  """
  update_AssessmentQuestion_Skill_by_pk(_set: AssessmentQuestion_Skill_set_input, pk_columns: AssessmentQuestion_Skill_pk_columns_input!): AssessmentQuestion_Skill
  """
  update multiples rows of table: "AssessmentQuestion_Skill"
  """
  update_AssessmentQuestion_Skill_many(updates: [AssessmentQuestion_Skill_updates!]!): [AssessmentQuestion_Skill_mutation_response]
  """
  update single row of the table: "AssessmentQuestion"
  """
  update_AssessmentQuestion_by_pk(_append: AssessmentQuestion_append_input, _delete_at_path: AssessmentQuestion_delete_at_path_input, _delete_elem: AssessmentQuestion_delete_elem_input, _delete_key: AssessmentQuestion_delete_key_input, _inc: AssessmentQuestion_inc_input, _prepend: AssessmentQuestion_prepend_input, _set: AssessmentQuestion_set_input, pk_columns: AssessmentQuestion_pk_columns_input!): AssessmentQuestion
  """
  update multiples rows of table: "AssessmentQuestion"
  """
  update_AssessmentQuestion_many(updates: [AssessmentQuestion_updates!]!): [AssessmentQuestion_mutation_response]
  """
  update data of the table: "Assessment_AssessmentQuestion"
  """
  update_Assessment_AssessmentQuestion(_set: Assessment_AssessmentQuestion_set_input, where: Assessment_AssessmentQuestion_bool_exp!): Assessment_AssessmentQuestion_mutation_response
  """
  update single row of the table: "Assessment_AssessmentQuestion"
  """
  update_Assessment_AssessmentQuestion_by_pk(_set: Assessment_AssessmentQuestion_set_input, pk_columns: Assessment_AssessmentQuestion_pk_columns_input!): Assessment_AssessmentQuestion
  """
  update multiples rows of table: "Assessment_AssessmentQuestion"
  """
  update_Assessment_AssessmentQuestion_many(updates: [Assessment_AssessmentQuestion_updates!]!): [Assessment_AssessmentQuestion_mutation_response]
  """
  update single row of the table: "Assessment"
  """
  update_Assessment_by_pk(_append: Assessment_append_input, _delete_at_path: Assessment_delete_at_path_input, _delete_elem: Assessment_delete_elem_input, _delete_key: Assessment_delete_key_input, _prepend: Assessment_prepend_input, _set: Assessment_set_input, pk_columns: Assessment_pk_columns_input!): Assessment
  """
  update multiples rows of table: "Assessment"
  """
  update_Assessment_many(updates: [Assessment_updates!]!): [Assessment_mutation_response]
  """
  update data of the table: "Candidate"
  """
  update_Candidate(_append: Candidate_append_input, _delete_at_path: Candidate_delete_at_path_input, _delete_elem: Candidate_delete_elem_input, _delete_key: Candidate_delete_key_input, _inc: Candidate_inc_input, _prepend: Candidate_prepend_input, _set: Candidate_set_input, where: Candidate_bool_exp!): Candidate_mutation_response
  """
  update data of the table: "CandidateNodeResponse"
  """
  update_CandidateNodeResponse(_append: CandidateNodeResponse_append_input, _delete_at_path: CandidateNodeResponse_delete_at_path_input, _delete_elem: CandidateNodeResponse_delete_elem_input, _delete_key: CandidateNodeResponse_delete_key_input, _inc: CandidateNodeResponse_inc_input, _prepend: CandidateNodeResponse_prepend_input, _set: CandidateNodeResponse_set_input, where: CandidateNodeResponse_bool_exp!): CandidateNodeResponse_mutation_response
  """
  update single row of the table: "CandidateNodeResponse"
  """
  update_CandidateNodeResponse_by_pk(_append: CandidateNodeResponse_append_input, _delete_at_path: CandidateNodeResponse_delete_at_path_input, _delete_elem: CandidateNodeResponse_delete_elem_input, _delete_key: CandidateNodeResponse_delete_key_input, _inc: CandidateNodeResponse_inc_input, _prepend: CandidateNodeResponse_prepend_input, _set: CandidateNodeResponse_set_input, pk_columns: CandidateNodeResponse_pk_columns_input!): CandidateNodeResponse
  """
  update multiples rows of table: "CandidateNodeResponse"
  """
  update_CandidateNodeResponse_many(updates: [CandidateNodeResponse_updates!]!): [CandidateNodeResponse_mutation_response]
  """
  update single row of the table: "Candidate"
  """
  update_Candidate_by_pk(_append: Candidate_append_input, _delete_at_path: Candidate_delete_at_path_input, _delete_elem: Candidate_delete_elem_input, _delete_key: Candidate_delete_key_input, _inc: Candidate_inc_input, _prepend: Candidate_prepend_input, _set: Candidate_set_input, pk_columns: Candidate_pk_columns_input!): Candidate
  """
  update multiples rows of table: "Candidate"
  """
  update_Candidate_many(updates: [Candidate_updates!]!): [Candidate_mutation_response]
  """
  update data of the table: "Company"
  """
  update_Company(_inc: Company_inc_input, _set: Company_set_input, where: Company_bool_exp!): Company_mutation_response
  """
  update single row of the table: "Company"
  """
  update_Company_by_pk(_inc: Company_inc_input, _set: Company_set_input, pk_columns: Company_pk_columns_input!): Company
  """
  update multiples rows of table: "Company"
  """
  update_Company_many(updates: [Company_updates!]!): [Company_mutation_response]
  """
  update data of the table: "Conversation"
  """
  update_Conversation(_set: Conversation_set_input, where: Conversation_bool_exp!): Conversation_mutation_response
  """
  update single row of the table: "Conversation"
  """
  update_Conversation_by_pk(_set: Conversation_set_input, pk_columns: Conversation_pk_columns_input!): Conversation
  """
  update multiples rows of table: "Conversation"
  """
  update_Conversation_many(updates: [Conversation_updates!]!): [Conversation_mutation_response]
  """
  update data of the table: "Message"
  """
  update_Message(_set: Message_set_input, where: Message_bool_exp!): Message_mutation_response
  """
  update single row of the table: "Message"
  """
  update_Message_by_pk(_set: Message_set_input, pk_columns: Message_pk_columns_input!): Message
  """
  update multiples rows of table: "Message"
  """
  update_Message_many(updates: [Message_updates!]!): [Message_mutation_response]
  """
  update data of the table: "NodeLogs"
  """
  update_NodeLogs(_set: NodeLogs_set_input, where: NodeLogs_bool_exp!): NodeLogs_mutation_response
  """
  update single row of the table: "NodeLogs"
  """
  update_NodeLogs_by_pk(_set: NodeLogs_set_input, pk_columns: NodeLogs_pk_columns_input!): NodeLogs
  """
  update multiples rows of table: "NodeLogs"
  """
  update_NodeLogs_many(updates: [NodeLogs_updates!]!): [NodeLogs_mutation_response]
  """
  update data of the table: "Pipeline"
  """
  update_Pipeline(_append: Pipeline_append_input, _delete_at_path: Pipeline_delete_at_path_input, _delete_elem: Pipeline_delete_elem_input, _delete_key: Pipeline_delete_key_input, _prepend: Pipeline_prepend_input, _set: Pipeline_set_input, where: Pipeline_bool_exp!): Pipeline_mutation_response
  """
  update data of the table: "PipelineNode"
  """
  update_PipelineNode(_append: PipelineNode_append_input, _delete_at_path: PipelineNode_delete_at_path_input, _delete_elem: PipelineNode_delete_elem_input, _delete_key: PipelineNode_delete_key_input, _inc: PipelineNode_inc_input, _prepend: PipelineNode_prepend_input, _set: PipelineNode_set_input, where: PipelineNode_bool_exp!): PipelineNode_mutation_response
  """
  update single row of the table: "PipelineNode"
  """
  update_PipelineNode_by_pk(_append: PipelineNode_append_input, _delete_at_path: PipelineNode_delete_at_path_input, _delete_elem: PipelineNode_delete_elem_input, _delete_key: PipelineNode_delete_key_input, _inc: PipelineNode_inc_input, _prepend: PipelineNode_prepend_input, _set: PipelineNode_set_input, pk_columns: PipelineNode_pk_columns_input!): PipelineNode
  """
  update multiples rows of table: "PipelineNode"
  """
  update_PipelineNode_many(updates: [PipelineNode_updates!]!): [PipelineNode_mutation_response]
  """
  update single row of the table: "Pipeline"
  """
  update_Pipeline_by_pk(_append: Pipeline_append_input, _delete_at_path: Pipeline_delete_at_path_input, _delete_elem: Pipeline_delete_elem_input, _delete_key: Pipeline_delete_key_input, _prepend: Pipeline_prepend_input, _set: Pipeline_set_input, pk_columns: Pipeline_pk_columns_input!): Pipeline
  """
  update multiples rows of table: "Pipeline"
  """
  update_Pipeline_many(updates: [Pipeline_updates!]!): [Pipeline_mutation_response]
  """
  update data of the table: "Role"
  """
  update_Role(_set: Role_set_input, where: Role_bool_exp!): Role_mutation_response
  """
  update single row of the table: "Role"
  """
  update_Role_by_pk(_set: Role_set_input, pk_columns: Role_pk_columns_input!): Role
  """
  update multiples rows of table: "Role"
  """
  update_Role_many(updates: [Role_updates!]!): [Role_mutation_response]
  """
  update data of the table: "Skill"
  """
  update_Skill(_set: Skill_set_input, where: Skill_bool_exp!): Skill_mutation_response
  """
  update data of the table: "Skill_Role"
  """
  update_Skill_Role(_set: Skill_Role_set_input, where: Skill_Role_bool_exp!): Skill_Role_mutation_response
  """
  update single row of the table: "Skill_Role"
  """
  update_Skill_Role_by_pk(_set: Skill_Role_set_input, pk_columns: Skill_Role_pk_columns_input!): Skill_Role
  """
  update multiples rows of table: "Skill_Role"
  """
  update_Skill_Role_many(updates: [Skill_Role_updates!]!): [Skill_Role_mutation_response]
  """
  update single row of the table: "Skill"
  """
  update_Skill_by_pk(_set: Skill_set_input, pk_columns: Skill_pk_columns_input!): Skill
  """
  update multiples rows of table: "Skill"
  """
  update_Skill_many(updates: [Skill_updates!]!): [Skill_mutation_response]
  """
  update data of the table: "Transaction"
  """
  update_Transaction(_inc: Transaction_inc_input, _set: Transaction_set_input, where: Transaction_bool_exp!): Transaction_mutation_response
  """
  update single row of the table: "Transaction"
  """
  update_Transaction_by_pk(_inc: Transaction_inc_input, _set: Transaction_set_input, pk_columns: Transaction_pk_columns_input!): Transaction
  """
  update multiples rows of table: "Transaction"
  """
  update_Transaction_many(updates: [Transaction_updates!]!): [Transaction_mutation_response]
  """
  update data of the table: "User"
  """
  update_User(_set: User_set_input, where: User_bool_exp!): User_mutation_response
  """
  update single row of the table: "User"
  """
  update_User_by_pk(_set: User_set_input, pk_columns: User_pk_columns_input!): User
  """
  update multiples rows of table: "User"
  """
  update_User_many(updates: [User_updates!]!): [User_mutation_response]
  """
  Verify company member
  """
  verifyCompanyMember(arg: VerifyCompanyMemberInput!): ResponsePayload!
}

"""
Stores node logs triggered by candidate
"""
type NodeLogs {
  """
  An object relationship
  """
  Candidate: Candidate!
  """
  An object relationship
  """
  Node: PipelineNode!
  candidate_id: uuid!
  created_at: timestamptz!
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
  error_message: String
  id: uuid!
  node_id: uuid!
  notes: String
  """
  enum type: "pending" | "error" | "success"
  """
  status: String!
  updated_at: timestamptz
}

"""
aggregated selection of "NodeLogs"
"""
type NodeLogs_aggregate {
  aggregate: NodeLogs_aggregate_fields
  nodes: [NodeLogs!]!
}

"""
aggregate fields of "NodeLogs"
"""
type NodeLogs_aggregate_fields {
  avg: NodeLogs_avg_fields
  count(columns: [NodeLogs_select_column!], distinct: Boolean): Int!
  max: NodeLogs_max_fields
  min: NodeLogs_min_fields
  stddev: NodeLogs_stddev_fields
  stddev_pop: NodeLogs_stddev_pop_fields
  stddev_samp: NodeLogs_stddev_samp_fields
  sum: NodeLogs_sum_fields
  var_pop: NodeLogs_var_pop_fields
  var_samp: NodeLogs_var_samp_fields
  variance: NodeLogs_variance_fields
}

"""
aggregate avg on columns
"""
type NodeLogs_avg_fields {
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
}

"""
aggregate max on columns
"""
type NodeLogs_max_fields {
  candidate_id: uuid
  created_at: timestamptz
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
  error_message: String
  id: uuid
  node_id: uuid
  notes: String
  """
  enum type: "pending" | "error" | "success"
  """
  status: String
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type NodeLogs_min_fields {
  candidate_id: uuid
  created_at: timestamptz
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
  error_message: String
  id: uuid
  node_id: uuid
  notes: String
  """
  enum type: "pending" | "error" | "success"
  """
  status: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "NodeLogs"
"""
type NodeLogs_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [NodeLogs!]!
}

"""
aggregate stddev on columns
"""
type NodeLogs_stddev_fields {
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
}

"""
aggregate stddev_pop on columns
"""
type NodeLogs_stddev_pop_fields {
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
}

"""
aggregate stddev_samp on columns
"""
type NodeLogs_stddev_samp_fields {
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
}

"""
aggregate sum on columns
"""
type NodeLogs_sum_fields {
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
}

"""
aggregate var_pop on columns
"""
type NodeLogs_var_pop_fields {
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
}

"""
aggregate var_samp on columns
"""
type NodeLogs_var_samp_fields {
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
}

"""
aggregate variance on columns
"""
type NodeLogs_variance_fields {
  """
  Duration in seconds between created_at and updated_at
  """
  duration_seconds: bigint
}

"""
Pipelines
"""
type Pipeline {
  """
  An array relationship
  """
  Candidates(distinct_on: [Candidate_select_column!], limit: Int, offset: Int, order_by: [Candidate_order_by!], where: Candidate_bool_exp): [Candidate!]!
  """
  An aggregate relationship
  """
  Candidates_aggregate(distinct_on: [Candidate_select_column!], limit: Int, offset: Int, order_by: [Candidate_order_by!], where: Candidate_bool_exp): Candidate_aggregate!
  """
  An object relationship
  """
  Company: Company!
  """
  An array relationship
  """
  Nodes(distinct_on: [PipelineNode_select_column!], limit: Int, offset: Int, order_by: [PipelineNode_order_by!], where: PipelineNode_bool_exp): [PipelineNode!]!
  """
  An aggregate relationship
  """
  Nodes_aggregate(distinct_on: [PipelineNode_select_column!], limit: Int, offset: Int, order_by: [PipelineNode_order_by!], where: PipelineNode_bool_exp): PipelineNode_aggregate!
  active: Boolean!
  company_id: uuid!
  config(path: String): jsonb
  created_at: timestamptz!
  id: uuid!
  job_description: String!
  job_title: String!
  job_type: String!
  location: String!
  name: String!
  node_flow(path: String): jsonb!
  updated_at: timestamptz!
  workplace_type: String!
}

"""
aggregated selection of "Pipeline"
"""
type Pipeline_aggregate {
  aggregate: Pipeline_aggregate_fields
  nodes: [Pipeline!]!
}

"""
aggregate fields of "Pipeline"
"""
type Pipeline_aggregate_fields {
  count(columns: [Pipeline_select_column!], distinct: Boolean): Int!
  max: Pipeline_max_fields
  min: Pipeline_min_fields
}

"""
aggregate max on columns
"""
type Pipeline_max_fields {
  company_id: uuid
  created_at: timestamptz
  id: uuid
  job_description: String
  job_title: String
  job_type: String
  location: String
  name: String
  updated_at: timestamptz
  workplace_type: String
}

"""
aggregate min on columns
"""
type Pipeline_min_fields {
  company_id: uuid
  created_at: timestamptz
  id: uuid
  job_description: String
  job_title: String
  job_type: String
  location: String
  name: String
  updated_at: timestamptz
  workplace_type: String
}

"""
response of any mutation on the table "Pipeline"
"""
type Pipeline_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Pipeline!]!
}

"""
Nodes in a Pipeline
"""
type PipelineNode {
  """
  An array relationship
  """
  CandidateResponses(distinct_on: [CandidateNodeResponse_select_column!], limit: Int, offset: Int, order_by: [CandidateNodeResponse_order_by!], where: CandidateNodeResponse_bool_exp): [CandidateNodeResponse!]!
  """
  An aggregate relationship
  """
  CandidateResponses_aggregate(distinct_on: [CandidateNodeResponse_select_column!], limit: Int, offset: Int, order_by: [CandidateNodeResponse_order_by!], where: CandidateNodeResponse_bool_exp): CandidateNodeResponse_aggregate!
  """
  An object relationship
  """
  Pipeline: Pipeline!
  id: uuid!
  metadata(path: String): jsonb!
  node_flow_id: Int!
  pipeline_id: uuid!
  type: String!
}

"""
aggregated selection of "PipelineNode"
"""
type PipelineNode_aggregate {
  aggregate: PipelineNode_aggregate_fields
  nodes: [PipelineNode!]!
}

"""
aggregate fields of "PipelineNode"
"""
type PipelineNode_aggregate_fields {
  avg: PipelineNode_avg_fields
  count(columns: [PipelineNode_select_column!], distinct: Boolean): Int!
  max: PipelineNode_max_fields
  min: PipelineNode_min_fields
  stddev: PipelineNode_stddev_fields
  stddev_pop: PipelineNode_stddev_pop_fields
  stddev_samp: PipelineNode_stddev_samp_fields
  sum: PipelineNode_sum_fields
  var_pop: PipelineNode_var_pop_fields
  var_samp: PipelineNode_var_samp_fields
  variance: PipelineNode_variance_fields
}

"""
aggregate avg on columns
"""
type PipelineNode_avg_fields {
  node_flow_id: Float
}

"""
aggregate max on columns
"""
type PipelineNode_max_fields {
  id: uuid
  node_flow_id: Int
  pipeline_id: uuid
  type: String
}

"""
aggregate min on columns
"""
type PipelineNode_min_fields {
  id: uuid
  node_flow_id: Int
  pipeline_id: uuid
  type: String
}

"""
response of any mutation on the table "PipelineNode"
"""
type PipelineNode_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [PipelineNode!]!
}

"""
aggregate stddev on columns
"""
type PipelineNode_stddev_fields {
  node_flow_id: Float
}

"""
aggregate stddev_pop on columns
"""
type PipelineNode_stddev_pop_fields {
  node_flow_id: Float
}

"""
aggregate stddev_samp on columns
"""
type PipelineNode_stddev_samp_fields {
  node_flow_id: Float
}

"""
aggregate sum on columns
"""
type PipelineNode_sum_fields {
  node_flow_id: Int
}

"""
aggregate var_pop on columns
"""
type PipelineNode_var_pop_fields {
  node_flow_id: Float
}

"""
aggregate var_samp on columns
"""
type PipelineNode_var_samp_fields {
  node_flow_id: Float
}

"""
aggregate variance on columns
"""
type PipelineNode_variance_fields {
  node_flow_id: Float
}

type query_root {
  """
  fetch data from the table: "Assessment"
  """
  Assessment(distinct_on: [Assessment_select_column!], limit: Int, offset: Int, order_by: [Assessment_order_by!], where: Assessment_bool_exp): [Assessment!]!
  """
  fetch data from the table: "AssessmentCandidate"
  """
  AssessmentCandidate(distinct_on: [AssessmentCandidate_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidate_order_by!], where: AssessmentCandidate_bool_exp): [AssessmentCandidate!]!
  """
  fetch data from the table: "AssessmentCandidateAnswer"
  """
  AssessmentCandidateAnswer(distinct_on: [AssessmentCandidateAnswer_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidateAnswer_order_by!], where: AssessmentCandidateAnswer_bool_exp): [AssessmentCandidateAnswer!]!
  """
  fetch aggregated fields from the table: "AssessmentCandidateAnswer"
  """
  AssessmentCandidateAnswer_aggregate(distinct_on: [AssessmentCandidateAnswer_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidateAnswer_order_by!], where: AssessmentCandidateAnswer_bool_exp): AssessmentCandidateAnswer_aggregate!
  """
  fetch data from the table: "AssessmentCandidateAnswer" using primary key columns
  """
  AssessmentCandidateAnswer_by_pk(id: uuid!): AssessmentCandidateAnswer
  """
  fetch aggregated fields from the table: "AssessmentCandidate"
  """
  AssessmentCandidate_aggregate(distinct_on: [AssessmentCandidate_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidate_order_by!], where: AssessmentCandidate_bool_exp): AssessmentCandidate_aggregate!
  """
  fetch data from the table: "AssessmentCandidate" using primary key columns
  """
  AssessmentCandidate_by_pk(id: uuid!): AssessmentCandidate
  """
  fetch data from the table: "AssessmentQuestion"
  """
  AssessmentQuestion(distinct_on: [AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_order_by!], where: AssessmentQuestion_bool_exp): [AssessmentQuestion!]!
  """
  fetch data from the table: "AssessmentQuestion_Skill"
  """
  AssessmentQuestion_Skill(distinct_on: [AssessmentQuestion_Skill_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_Skill_order_by!], where: AssessmentQuestion_Skill_bool_exp): [AssessmentQuestion_Skill!]!
  """
  fetch aggregated fields from the table: "AssessmentQuestion_Skill"
  """
  AssessmentQuestion_Skill_aggregate(distinct_on: [AssessmentQuestion_Skill_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_Skill_order_by!], where: AssessmentQuestion_Skill_bool_exp): AssessmentQuestion_Skill_aggregate!
  """
  fetch data from the table: "AssessmentQuestion_Skill" using primary key columns
  """
  AssessmentQuestion_Skill_by_pk(id: uuid!): AssessmentQuestion_Skill
  """
  fetch aggregated fields from the table: "AssessmentQuestion"
  """
  AssessmentQuestion_aggregate(distinct_on: [AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_order_by!], where: AssessmentQuestion_bool_exp): AssessmentQuestion_aggregate!
  """
  fetch data from the table: "AssessmentQuestion" using primary key columns
  """
  AssessmentQuestion_by_pk(id: uuid!): AssessmentQuestion
  """
  fetch data from the table: "Assessment_AssessmentQuestion"
  """
  Assessment_AssessmentQuestion(distinct_on: [Assessment_AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [Assessment_AssessmentQuestion_order_by!], where: Assessment_AssessmentQuestion_bool_exp): [Assessment_AssessmentQuestion!]!
  """
  fetch aggregated fields from the table: "Assessment_AssessmentQuestion"
  """
  Assessment_AssessmentQuestion_aggregate(distinct_on: [Assessment_AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [Assessment_AssessmentQuestion_order_by!], where: Assessment_AssessmentQuestion_bool_exp): Assessment_AssessmentQuestion_aggregate!
  """
  fetch data from the table: "Assessment_AssessmentQuestion" using primary key columns
  """
  Assessment_AssessmentQuestion_by_pk(id: uuid!): Assessment_AssessmentQuestion
  """
  fetch aggregated fields from the table: "Assessment"
  """
  Assessment_aggregate(distinct_on: [Assessment_select_column!], limit: Int, offset: Int, order_by: [Assessment_order_by!], where: Assessment_bool_exp): Assessment_aggregate!
  """
  fetch data from the table: "Assessment" using primary key columns
  """
  Assessment_by_pk(id: uuid!): Assessment
  """
  fetch data from the table: "Candidate"
  """
  Candidate(distinct_on: [Candidate_select_column!], limit: Int, offset: Int, order_by: [Candidate_order_by!], where: Candidate_bool_exp): [Candidate!]!
  """
  fetch data from the table: "CandidateNodeResponse"
  """
  CandidateNodeResponse(distinct_on: [CandidateNodeResponse_select_column!], limit: Int, offset: Int, order_by: [CandidateNodeResponse_order_by!], where: CandidateNodeResponse_bool_exp): [CandidateNodeResponse!]!
  """
  fetch aggregated fields from the table: "CandidateNodeResponse"
  """
  CandidateNodeResponse_aggregate(distinct_on: [CandidateNodeResponse_select_column!], limit: Int, offset: Int, order_by: [CandidateNodeResponse_order_by!], where: CandidateNodeResponse_bool_exp): CandidateNodeResponse_aggregate!
  """
  fetch data from the table: "CandidateNodeResponse" using primary key columns
  """
  CandidateNodeResponse_by_pk(id: uuid!): CandidateNodeResponse
  """
  fetch aggregated fields from the table: "Candidate"
  """
  Candidate_aggregate(distinct_on: [Candidate_select_column!], limit: Int, offset: Int, order_by: [Candidate_order_by!], where: Candidate_bool_exp): Candidate_aggregate!
  """
  fetch data from the table: "Candidate" using primary key columns
  """
  Candidate_by_pk(id: uuid!): Candidate
  """
  fetch data from the table: "Company"
  """
  Company(distinct_on: [Company_select_column!], limit: Int, offset: Int, order_by: [Company_order_by!], where: Company_bool_exp): [Company!]!
  """
  fetch aggregated fields from the table: "Company"
  """
  Company_aggregate(distinct_on: [Company_select_column!], limit: Int, offset: Int, order_by: [Company_order_by!], where: Company_bool_exp): Company_aggregate!
  """
  fetch data from the table: "Company" using primary key columns
  """
  Company_by_pk(id: uuid!): Company
  """
  fetch data from the table: "Conversation"
  """
  Conversation(distinct_on: [Conversation_select_column!], limit: Int, offset: Int, order_by: [Conversation_order_by!], where: Conversation_bool_exp): [Conversation!]!
  """
  fetch aggregated fields from the table: "Conversation"
  """
  Conversation_aggregate(distinct_on: [Conversation_select_column!], limit: Int, offset: Int, order_by: [Conversation_order_by!], where: Conversation_bool_exp): Conversation_aggregate!
  """
  fetch data from the table: "Conversation" using primary key columns
  """
  Conversation_by_pk(id: uuid!): Conversation
  """
  fetch data from the table: "Message"
  """
  Message(distinct_on: [Message_select_column!], limit: Int, offset: Int, order_by: [Message_order_by!], where: Message_bool_exp): [Message!]!
  """
  fetch aggregated fields from the table: "Message"
  """
  Message_aggregate(distinct_on: [Message_select_column!], limit: Int, offset: Int, order_by: [Message_order_by!], where: Message_bool_exp): Message_aggregate!
  """
  fetch data from the table: "Message" using primary key columns
  """
  Message_by_pk(id: uuid!): Message
  """
  fetch data from the table: "NodeLogs"
  """
  NodeLogs(distinct_on: [NodeLogs_select_column!], limit: Int, offset: Int, order_by: [NodeLogs_order_by!], where: NodeLogs_bool_exp): [NodeLogs!]!
  """
  fetch aggregated fields from the table: "NodeLogs"
  """
  NodeLogs_aggregate(distinct_on: [NodeLogs_select_column!], limit: Int, offset: Int, order_by: [NodeLogs_order_by!], where: NodeLogs_bool_exp): NodeLogs_aggregate!
  """
  fetch data from the table: "NodeLogs" using primary key columns
  """
  NodeLogs_by_pk(id: uuid!): NodeLogs
  """
  fetch data from the table: "Pipeline"
  """
  Pipeline(distinct_on: [Pipeline_select_column!], limit: Int, offset: Int, order_by: [Pipeline_order_by!], where: Pipeline_bool_exp): [Pipeline!]!
  """
  fetch data from the table: "PipelineNode"
  """
  PipelineNode(distinct_on: [PipelineNode_select_column!], limit: Int, offset: Int, order_by: [PipelineNode_order_by!], where: PipelineNode_bool_exp): [PipelineNode!]!
  """
  fetch aggregated fields from the table: "PipelineNode"
  """
  PipelineNode_aggregate(distinct_on: [PipelineNode_select_column!], limit: Int, offset: Int, order_by: [PipelineNode_order_by!], where: PipelineNode_bool_exp): PipelineNode_aggregate!
  """
  fetch data from the table: "PipelineNode" using primary key columns
  """
  PipelineNode_by_pk(id: uuid!): PipelineNode
  """
  fetch aggregated fields from the table: "Pipeline"
  """
  Pipeline_aggregate(distinct_on: [Pipeline_select_column!], limit: Int, offset: Int, order_by: [Pipeline_order_by!], where: Pipeline_bool_exp): Pipeline_aggregate!
  """
  fetch data from the table: "Pipeline" using primary key columns
  """
  Pipeline_by_pk(id: uuid!): Pipeline
  """
  fetch data from the table: "Role"
  """
  Role(distinct_on: [Role_select_column!], limit: Int, offset: Int, order_by: [Role_order_by!], where: Role_bool_exp): [Role!]!
  """
  fetch aggregated fields from the table: "Role"
  """
  Role_aggregate(distinct_on: [Role_select_column!], limit: Int, offset: Int, order_by: [Role_order_by!], where: Role_bool_exp): Role_aggregate!
  """
  fetch data from the table: "Role" using primary key columns
  """
  Role_by_pk(id: uuid!): Role
  """
  fetch data from the table: "Skill"
  """
  Skill(distinct_on: [Skill_select_column!], limit: Int, offset: Int, order_by: [Skill_order_by!], where: Skill_bool_exp): [Skill!]!
  """
  fetch data from the table: "Skill_Role"
  """
  Skill_Role(distinct_on: [Skill_Role_select_column!], limit: Int, offset: Int, order_by: [Skill_Role_order_by!], where: Skill_Role_bool_exp): [Skill_Role!]!
  """
  fetch aggregated fields from the table: "Skill_Role"
  """
  Skill_Role_aggregate(distinct_on: [Skill_Role_select_column!], limit: Int, offset: Int, order_by: [Skill_Role_order_by!], where: Skill_Role_bool_exp): Skill_Role_aggregate!
  """
  fetch data from the table: "Skill_Role" using primary key columns
  """
  Skill_Role_by_pk(id: uuid!): Skill_Role
  """
  fetch aggregated fields from the table: "Skill"
  """
  Skill_aggregate(distinct_on: [Skill_select_column!], limit: Int, offset: Int, order_by: [Skill_order_by!], where: Skill_bool_exp): Skill_aggregate!
  """
  fetch data from the table: "Skill" using primary key columns
  """
  Skill_by_pk(id: uuid!): Skill
  """
  fetch data from the table: "Transaction"
  """
  Transaction(distinct_on: [Transaction_select_column!], limit: Int, offset: Int, order_by: [Transaction_order_by!], where: Transaction_bool_exp): [Transaction!]!
  """
  fetch aggregated fields from the table: "Transaction"
  """
  Transaction_aggregate(distinct_on: [Transaction_select_column!], limit: Int, offset: Int, order_by: [Transaction_order_by!], where: Transaction_bool_exp): Transaction_aggregate!
  """
  fetch data from the table: "Transaction" using primary key columns
  """
  Transaction_by_pk(id: uuid!): Transaction
  """
  fetch data from the table: "User"
  """
  User(distinct_on: [User_select_column!], limit: Int, offset: Int, order_by: [User_order_by!], where: User_bool_exp): [User!]!
  """
  fetch aggregated fields from the table: "User"
  """
  User_aggregate(distinct_on: [User_select_column!], limit: Int, offset: Int, order_by: [User_order_by!], where: User_bool_exp): User_aggregate!
  """
  fetch data from the table: "User" using primary key columns
  """
  User_by_pk(id: uuid!): User
  """
  My User Query
  """
  myUser: User_MyUser
}

type ResponsePayload {
  error: String
  id: String
  status: Boolean
  token: String
}

type ResponseStatus {
  error: String
  message: String
  status: Boolean
}

"""
columns and relationships of "Role"
"""
type Role {
  """
  An array relationship
  """
  Skills(distinct_on: [Skill_Role_select_column!], limit: Int, offset: Int, order_by: [Skill_Role_order_by!], where: Skill_Role_bool_exp): [Skill_Role!]!
  """
  An aggregate relationship
  """
  Skills_aggregate(distinct_on: [Skill_Role_select_column!], limit: Int, offset: Int, order_by: [Skill_Role_order_by!], where: Skill_Role_bool_exp): Skill_Role_aggregate!
  id: uuid!
  label: String!
}

"""
aggregated selection of "Role"
"""
type Role_aggregate {
  aggregate: Role_aggregate_fields
  nodes: [Role!]!
}

"""
aggregate fields of "Role"
"""
type Role_aggregate_fields {
  count(columns: [Role_select_column!], distinct: Boolean): Int!
  max: Role_max_fields
  min: Role_min_fields
}

"""
aggregate max on columns
"""
type Role_max_fields {
  id: uuid
  label: String
}

"""
aggregate min on columns
"""
type Role_min_fields {
  id: uuid
  label: String
}

"""
response of any mutation on the table "Role"
"""
type Role_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Role!]!
}

"""
columns and relationships of "Skill"
"""
type Skill {
  """
  An array relationship
  """
  Roles(distinct_on: [Skill_Role_select_column!], limit: Int, offset: Int, order_by: [Skill_Role_order_by!], where: Skill_Role_bool_exp): [Skill_Role!]!
  """
  An aggregate relationship
  """
  Roles_aggregate(distinct_on: [Skill_Role_select_column!], limit: Int, offset: Int, order_by: [Skill_Role_order_by!], where: Skill_Role_bool_exp): Skill_Role_aggregate!
  icon_svg: String
  id: uuid!
  label: String!
}

"""
aggregated selection of "Skill"
"""
type Skill_aggregate {
  aggregate: Skill_aggregate_fields
  nodes: [Skill!]!
}

"""
aggregate fields of "Skill"
"""
type Skill_aggregate_fields {
  count(columns: [Skill_select_column!], distinct: Boolean): Int!
  max: Skill_max_fields
  min: Skill_min_fields
}

"""
aggregate max on columns
"""
type Skill_max_fields {
  icon_svg: String
  id: uuid
  label: String
}

"""
aggregate min on columns
"""
type Skill_min_fields {
  icon_svg: String
  id: uuid
  label: String
}

"""
response of any mutation on the table "Skill"
"""
type Skill_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Skill!]!
}

"""
Associative Table for many-to-many relationship between Skills and Roles
"""
type Skill_Role {
  """
  An object relationship
  """
  Role: Role!
  """
  An object relationship
  """
  Skill: Skill!
  id: uuid!
  role_id: uuid!
  skill_id: uuid!
}

"""
aggregated selection of "Skill_Role"
"""
type Skill_Role_aggregate {
  aggregate: Skill_Role_aggregate_fields
  nodes: [Skill_Role!]!
}

"""
aggregate fields of "Skill_Role"
"""
type Skill_Role_aggregate_fields {
  count(columns: [Skill_Role_select_column!], distinct: Boolean): Int!
  max: Skill_Role_max_fields
  min: Skill_Role_min_fields
}

"""
aggregate max on columns
"""
type Skill_Role_max_fields {
  id: uuid
  role_id: uuid
  skill_id: uuid
}

"""
aggregate min on columns
"""
type Skill_Role_min_fields {
  id: uuid
  role_id: uuid
  skill_id: uuid
}

"""
response of any mutation on the table "Skill_Role"
"""
type Skill_Role_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Skill_Role!]!
}

type subscription_root {
  """
  fetch data from the table: "Assessment"
  """
  Assessment(distinct_on: [Assessment_select_column!], limit: Int, offset: Int, order_by: [Assessment_order_by!], where: Assessment_bool_exp): [Assessment!]!
  """
  fetch data from the table: "AssessmentCandidate"
  """
  AssessmentCandidate(distinct_on: [AssessmentCandidate_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidate_order_by!], where: AssessmentCandidate_bool_exp): [AssessmentCandidate!]!
  """
  fetch data from the table: "AssessmentCandidateAnswer"
  """
  AssessmentCandidateAnswer(distinct_on: [AssessmentCandidateAnswer_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidateAnswer_order_by!], where: AssessmentCandidateAnswer_bool_exp): [AssessmentCandidateAnswer!]!
  """
  fetch aggregated fields from the table: "AssessmentCandidateAnswer"
  """
  AssessmentCandidateAnswer_aggregate(distinct_on: [AssessmentCandidateAnswer_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidateAnswer_order_by!], where: AssessmentCandidateAnswer_bool_exp): AssessmentCandidateAnswer_aggregate!
  """
  fetch data from the table: "AssessmentCandidateAnswer" using primary key columns
  """
  AssessmentCandidateAnswer_by_pk(id: uuid!): AssessmentCandidateAnswer
  """
  fetch data from the table in a streaming manner: "AssessmentCandidateAnswer"
  """
  AssessmentCandidateAnswer_stream(batch_size: Int!, cursor: [AssessmentCandidateAnswer_stream_cursor_input]!, where: AssessmentCandidateAnswer_bool_exp): [AssessmentCandidateAnswer!]!
  """
  fetch aggregated fields from the table: "AssessmentCandidate"
  """
  AssessmentCandidate_aggregate(distinct_on: [AssessmentCandidate_select_column!], limit: Int, offset: Int, order_by: [AssessmentCandidate_order_by!], where: AssessmentCandidate_bool_exp): AssessmentCandidate_aggregate!
  """
  fetch data from the table: "AssessmentCandidate" using primary key columns
  """
  AssessmentCandidate_by_pk(id: uuid!): AssessmentCandidate
  """
  fetch data from the table in a streaming manner: "AssessmentCandidate"
  """
  AssessmentCandidate_stream(batch_size: Int!, cursor: [AssessmentCandidate_stream_cursor_input]!, where: AssessmentCandidate_bool_exp): [AssessmentCandidate!]!
  """
  fetch data from the table: "AssessmentQuestion"
  """
  AssessmentQuestion(distinct_on: [AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_order_by!], where: AssessmentQuestion_bool_exp): [AssessmentQuestion!]!
  """
  fetch data from the table: "AssessmentQuestion_Skill"
  """
  AssessmentQuestion_Skill(distinct_on: [AssessmentQuestion_Skill_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_Skill_order_by!], where: AssessmentQuestion_Skill_bool_exp): [AssessmentQuestion_Skill!]!
  """
  fetch aggregated fields from the table: "AssessmentQuestion_Skill"
  """
  AssessmentQuestion_Skill_aggregate(distinct_on: [AssessmentQuestion_Skill_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_Skill_order_by!], where: AssessmentQuestion_Skill_bool_exp): AssessmentQuestion_Skill_aggregate!
  """
  fetch data from the table: "AssessmentQuestion_Skill" using primary key columns
  """
  AssessmentQuestion_Skill_by_pk(id: uuid!): AssessmentQuestion_Skill
  """
  fetch data from the table in a streaming manner: "AssessmentQuestion_Skill"
  """
  AssessmentQuestion_Skill_stream(batch_size: Int!, cursor: [AssessmentQuestion_Skill_stream_cursor_input]!, where: AssessmentQuestion_Skill_bool_exp): [AssessmentQuestion_Skill!]!
  """
  fetch aggregated fields from the table: "AssessmentQuestion"
  """
  AssessmentQuestion_aggregate(distinct_on: [AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [AssessmentQuestion_order_by!], where: AssessmentQuestion_bool_exp): AssessmentQuestion_aggregate!
  """
  fetch data from the table: "AssessmentQuestion" using primary key columns
  """
  AssessmentQuestion_by_pk(id: uuid!): AssessmentQuestion
  """
  fetch data from the table in a streaming manner: "AssessmentQuestion"
  """
  AssessmentQuestion_stream(batch_size: Int!, cursor: [AssessmentQuestion_stream_cursor_input]!, where: AssessmentQuestion_bool_exp): [AssessmentQuestion!]!
  """
  fetch data from the table: "Assessment_AssessmentQuestion"
  """
  Assessment_AssessmentQuestion(distinct_on: [Assessment_AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [Assessment_AssessmentQuestion_order_by!], where: Assessment_AssessmentQuestion_bool_exp): [Assessment_AssessmentQuestion!]!
  """
  fetch aggregated fields from the table: "Assessment_AssessmentQuestion"
  """
  Assessment_AssessmentQuestion_aggregate(distinct_on: [Assessment_AssessmentQuestion_select_column!], limit: Int, offset: Int, order_by: [Assessment_AssessmentQuestion_order_by!], where: Assessment_AssessmentQuestion_bool_exp): Assessment_AssessmentQuestion_aggregate!
  """
  fetch data from the table: "Assessment_AssessmentQuestion" using primary key columns
  """
  Assessment_AssessmentQuestion_by_pk(id: uuid!): Assessment_AssessmentQuestion
  """
  fetch data from the table in a streaming manner: "Assessment_AssessmentQuestion"
  """
  Assessment_AssessmentQuestion_stream(batch_size: Int!, cursor: [Assessment_AssessmentQuestion_stream_cursor_input]!, where: Assessment_AssessmentQuestion_bool_exp): [Assessment_AssessmentQuestion!]!
  """
  fetch aggregated fields from the table: "Assessment"
  """
  Assessment_aggregate(distinct_on: [Assessment_select_column!], limit: Int, offset: Int, order_by: [Assessment_order_by!], where: Assessment_bool_exp): Assessment_aggregate!
  """
  fetch data from the table: "Assessment" using primary key columns
  """
  Assessment_by_pk(id: uuid!): Assessment
  """
  fetch data from the table in a streaming manner: "Assessment"
  """
  Assessment_stream(batch_size: Int!, cursor: [Assessment_stream_cursor_input]!, where: Assessment_bool_exp): [Assessment!]!
  """
  fetch data from the table: "Candidate"
  """
  Candidate(distinct_on: [Candidate_select_column!], limit: Int, offset: Int, order_by: [Candidate_order_by!], where: Candidate_bool_exp): [Candidate!]!
  """
  fetch data from the table: "CandidateNodeResponse"
  """
  CandidateNodeResponse(distinct_on: [CandidateNodeResponse_select_column!], limit: Int, offset: Int, order_by: [CandidateNodeResponse_order_by!], where: CandidateNodeResponse_bool_exp): [CandidateNodeResponse!]!
  """
  fetch aggregated fields from the table: "CandidateNodeResponse"
  """
  CandidateNodeResponse_aggregate(distinct_on: [CandidateNodeResponse_select_column!], limit: Int, offset: Int, order_by: [CandidateNodeResponse_order_by!], where: CandidateNodeResponse_bool_exp): CandidateNodeResponse_aggregate!
  """
  fetch data from the table: "CandidateNodeResponse" using primary key columns
  """
  CandidateNodeResponse_by_pk(id: uuid!): CandidateNodeResponse
  """
  fetch data from the table in a streaming manner: "CandidateNodeResponse"
  """
  CandidateNodeResponse_stream(batch_size: Int!, cursor: [CandidateNodeResponse_stream_cursor_input]!, where: CandidateNodeResponse_bool_exp): [CandidateNodeResponse!]!
  """
  fetch aggregated fields from the table: "Candidate"
  """
  Candidate_aggregate(distinct_on: [Candidate_select_column!], limit: Int, offset: Int, order_by: [Candidate_order_by!], where: Candidate_bool_exp): Candidate_aggregate!
  """
  fetch data from the table: "Candidate" using primary key columns
  """
  Candidate_by_pk(id: uuid!): Candidate
  """
  fetch data from the table in a streaming manner: "Candidate"
  """
  Candidate_stream(batch_size: Int!, cursor: [Candidate_stream_cursor_input]!, where: Candidate_bool_exp): [Candidate!]!
  """
  fetch data from the table: "Company"
  """
  Company(distinct_on: [Company_select_column!], limit: Int, offset: Int, order_by: [Company_order_by!], where: Company_bool_exp): [Company!]!
  """
  fetch aggregated fields from the table: "Company"
  """
  Company_aggregate(distinct_on: [Company_select_column!], limit: Int, offset: Int, order_by: [Company_order_by!], where: Company_bool_exp): Company_aggregate!
  """
  fetch data from the table: "Company" using primary key columns
  """
  Company_by_pk(id: uuid!): Company
  """
  fetch data from the table in a streaming manner: "Company"
  """
  Company_stream(batch_size: Int!, cursor: [Company_stream_cursor_input]!, where: Company_bool_exp): [Company!]!
  """
  fetch data from the table: "Conversation"
  """
  Conversation(distinct_on: [Conversation_select_column!], limit: Int, offset: Int, order_by: [Conversation_order_by!], where: Conversation_bool_exp): [Conversation!]!
  """
  fetch aggregated fields from the table: "Conversation"
  """
  Conversation_aggregate(distinct_on: [Conversation_select_column!], limit: Int, offset: Int, order_by: [Conversation_order_by!], where: Conversation_bool_exp): Conversation_aggregate!
  """
  fetch data from the table: "Conversation" using primary key columns
  """
  Conversation_by_pk(id: uuid!): Conversation
  """
  fetch data from the table in a streaming manner: "Conversation"
  """
  Conversation_stream(batch_size: Int!, cursor: [Conversation_stream_cursor_input]!, where: Conversation_bool_exp): [Conversation!]!
  """
  fetch data from the table: "Message"
  """
  Message(distinct_on: [Message_select_column!], limit: Int, offset: Int, order_by: [Message_order_by!], where: Message_bool_exp): [Message!]!
  """
  fetch aggregated fields from the table: "Message"
  """
  Message_aggregate(distinct_on: [Message_select_column!], limit: Int, offset: Int, order_by: [Message_order_by!], where: Message_bool_exp): Message_aggregate!
  """
  fetch data from the table: "Message" using primary key columns
  """
  Message_by_pk(id: uuid!): Message
  """
  fetch data from the table in a streaming manner: "Message"
  """
  Message_stream(batch_size: Int!, cursor: [Message_stream_cursor_input]!, where: Message_bool_exp): [Message!]!
  """
  fetch data from the table: "NodeLogs"
  """
  NodeLogs(distinct_on: [NodeLogs_select_column!], limit: Int, offset: Int, order_by: [NodeLogs_order_by!], where: NodeLogs_bool_exp): [NodeLogs!]!
  """
  fetch aggregated fields from the table: "NodeLogs"
  """
  NodeLogs_aggregate(distinct_on: [NodeLogs_select_column!], limit: Int, offset: Int, order_by: [NodeLogs_order_by!], where: NodeLogs_bool_exp): NodeLogs_aggregate!
  """
  fetch data from the table: "NodeLogs" using primary key columns
  """
  NodeLogs_by_pk(id: uuid!): NodeLogs
  """
  fetch data from the table in a streaming manner: "NodeLogs"
  """
  NodeLogs_stream(batch_size: Int!, cursor: [NodeLogs_stream_cursor_input]!, where: NodeLogs_bool_exp): [NodeLogs!]!
  """
  fetch data from the table: "Pipeline"
  """
  Pipeline(distinct_on: [Pipeline_select_column!], limit: Int, offset: Int, order_by: [Pipeline_order_by!], where: Pipeline_bool_exp): [Pipeline!]!
  """
  fetch data from the table: "PipelineNode"
  """
  PipelineNode(distinct_on: [PipelineNode_select_column!], limit: Int, offset: Int, order_by: [PipelineNode_order_by!], where: PipelineNode_bool_exp): [PipelineNode!]!
  """
  fetch aggregated fields from the table: "PipelineNode"
  """
  PipelineNode_aggregate(distinct_on: [PipelineNode_select_column!], limit: Int, offset: Int, order_by: [PipelineNode_order_by!], where: PipelineNode_bool_exp): PipelineNode_aggregate!
  """
  fetch data from the table: "PipelineNode" using primary key columns
  """
  PipelineNode_by_pk(id: uuid!): PipelineNode
  """
  fetch data from the table in a streaming manner: "PipelineNode"
  """
  PipelineNode_stream(batch_size: Int!, cursor: [PipelineNode_stream_cursor_input]!, where: PipelineNode_bool_exp): [PipelineNode!]!
  """
  fetch aggregated fields from the table: "Pipeline"
  """
  Pipeline_aggregate(distinct_on: [Pipeline_select_column!], limit: Int, offset: Int, order_by: [Pipeline_order_by!], where: Pipeline_bool_exp): Pipeline_aggregate!
  """
  fetch data from the table: "Pipeline" using primary key columns
  """
  Pipeline_by_pk(id: uuid!): Pipeline
  """
  fetch data from the table in a streaming manner: "Pipeline"
  """
  Pipeline_stream(batch_size: Int!, cursor: [Pipeline_stream_cursor_input]!, where: Pipeline_bool_exp): [Pipeline!]!
  """
  fetch data from the table: "Role"
  """
  Role(distinct_on: [Role_select_column!], limit: Int, offset: Int, order_by: [Role_order_by!], where: Role_bool_exp): [Role!]!
  """
  fetch aggregated fields from the table: "Role"
  """
  Role_aggregate(distinct_on: [Role_select_column!], limit: Int, offset: Int, order_by: [Role_order_by!], where: Role_bool_exp): Role_aggregate!
  """
  fetch data from the table: "Role" using primary key columns
  """
  Role_by_pk(id: uuid!): Role
  """
  fetch data from the table in a streaming manner: "Role"
  """
  Role_stream(batch_size: Int!, cursor: [Role_stream_cursor_input]!, where: Role_bool_exp): [Role!]!
  """
  fetch data from the table: "Skill"
  """
  Skill(distinct_on: [Skill_select_column!], limit: Int, offset: Int, order_by: [Skill_order_by!], where: Skill_bool_exp): [Skill!]!
  """
  fetch data from the table: "Skill_Role"
  """
  Skill_Role(distinct_on: [Skill_Role_select_column!], limit: Int, offset: Int, order_by: [Skill_Role_order_by!], where: Skill_Role_bool_exp): [Skill_Role!]!
  """
  fetch aggregated fields from the table: "Skill_Role"
  """
  Skill_Role_aggregate(distinct_on: [Skill_Role_select_column!], limit: Int, offset: Int, order_by: [Skill_Role_order_by!], where: Skill_Role_bool_exp): Skill_Role_aggregate!
  """
  fetch data from the table: "Skill_Role" using primary key columns
  """
  Skill_Role_by_pk(id: uuid!): Skill_Role
  """
  fetch data from the table in a streaming manner: "Skill_Role"
  """
  Skill_Role_stream(batch_size: Int!, cursor: [Skill_Role_stream_cursor_input]!, where: Skill_Role_bool_exp): [Skill_Role!]!
  """
  fetch aggregated fields from the table: "Skill"
  """
  Skill_aggregate(distinct_on: [Skill_select_column!], limit: Int, offset: Int, order_by: [Skill_order_by!], where: Skill_bool_exp): Skill_aggregate!
  """
  fetch data from the table: "Skill" using primary key columns
  """
  Skill_by_pk(id: uuid!): Skill
  """
  fetch data from the table in a streaming manner: "Skill"
  """
  Skill_stream(batch_size: Int!, cursor: [Skill_stream_cursor_input]!, where: Skill_bool_exp): [Skill!]!
  """
  fetch data from the table: "Transaction"
  """
  Transaction(distinct_on: [Transaction_select_column!], limit: Int, offset: Int, order_by: [Transaction_order_by!], where: Transaction_bool_exp): [Transaction!]!
  """
  fetch aggregated fields from the table: "Transaction"
  """
  Transaction_aggregate(distinct_on: [Transaction_select_column!], limit: Int, offset: Int, order_by: [Transaction_order_by!], where: Transaction_bool_exp): Transaction_aggregate!
  """
  fetch data from the table: "Transaction" using primary key columns
  """
  Transaction_by_pk(id: uuid!): Transaction
  """
  fetch data from the table in a streaming manner: "Transaction"
  """
  Transaction_stream(batch_size: Int!, cursor: [Transaction_stream_cursor_input]!, where: Transaction_bool_exp): [Transaction!]!
  """
  fetch data from the table: "User"
  """
  User(distinct_on: [User_select_column!], limit: Int, offset: Int, order_by: [User_order_by!], where: User_bool_exp): [User!]!
  """
  fetch aggregated fields from the table: "User"
  """
  User_aggregate(distinct_on: [User_select_column!], limit: Int, offset: Int, order_by: [User_order_by!], where: User_bool_exp): User_aggregate!
  """
  fetch data from the table: "User" using primary key columns
  """
  User_by_pk(id: uuid!): User
  """
  fetch data from the table in a streaming manner: "User"
  """
  User_stream(batch_size: Int!, cursor: [User_stream_cursor_input]!, where: User_bool_exp): [User!]!
}

"""
Company Transactions
"""
type Transaction {
  """
  An object relationship
  """
  Company: Company!
  amount: float8!
  company_id: uuid!
  created_at: timestamptz!
  id: uuid!
  type: String!
}

"""
aggregated selection of "Transaction"
"""
type Transaction_aggregate {
  aggregate: Transaction_aggregate_fields
  nodes: [Transaction!]!
}

"""
aggregate fields of "Transaction"
"""
type Transaction_aggregate_fields {
  avg: Transaction_avg_fields
  count(columns: [Transaction_select_column!], distinct: Boolean): Int!
  max: Transaction_max_fields
  min: Transaction_min_fields
  stddev: Transaction_stddev_fields
  stddev_pop: Transaction_stddev_pop_fields
  stddev_samp: Transaction_stddev_samp_fields
  sum: Transaction_sum_fields
  var_pop: Transaction_var_pop_fields
  var_samp: Transaction_var_samp_fields
  variance: Transaction_variance_fields
}

"""
aggregate avg on columns
"""
type Transaction_avg_fields {
  amount: Float
}

"""
aggregate max on columns
"""
type Transaction_max_fields {
  amount: float8
  company_id: uuid
  created_at: timestamptz
  id: uuid
  type: String
}

"""
aggregate min on columns
"""
type Transaction_min_fields {
  amount: float8
  company_id: uuid
  created_at: timestamptz
  id: uuid
  type: String
}

"""
response of any mutation on the table "Transaction"
"""
type Transaction_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [Transaction!]!
}

"""
aggregate stddev on columns
"""
type Transaction_stddev_fields {
  amount: Float
}

"""
aggregate stddev_pop on columns
"""
type Transaction_stddev_pop_fields {
  amount: Float
}

"""
aggregate stddev_samp on columns
"""
type Transaction_stddev_samp_fields {
  amount: Float
}

"""
aggregate sum on columns
"""
type Transaction_sum_fields {
  amount: float8
}

"""
aggregate var_pop on columns
"""
type Transaction_var_pop_fields {
  amount: Float
}

"""
aggregate var_samp on columns
"""
type Transaction_var_samp_fields {
  amount: Float
}

"""
aggregate variance on columns
"""
type Transaction_variance_fields {
  amount: Float
}

"""
columns and relationships of "User"
"""
type User {
  """
  An object relationship
  """
  Company: Company!
  company_id: uuid!
  created_at: timestamptz!
  email: String!
  id: uuid!
  name: String
  password_hash: String!
  password_reset_token: String
  status: String!
  updated_at: timestamptz!
}

"""
aggregated selection of "User"
"""
type User_aggregate {
  aggregate: User_aggregate_fields
  nodes: [User!]!
}

"""
aggregate fields of "User"
"""
type User_aggregate_fields {
  count(columns: [User_select_column!], distinct: Boolean): Int!
  max: User_max_fields
  min: User_min_fields
}

"""
aggregate max on columns
"""
type User_max_fields {
  company_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  password_hash: String
  password_reset_token: String
  status: String
  updated_at: timestamptz
}

"""
aggregate min on columns
"""
type User_min_fields {
  company_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  password_hash: String
  password_reset_token: String
  status: String
  updated_at: timestamptz
}

"""
response of any mutation on the table "User"
"""
type User_mutation_response {
  """
  number of rows affected by the mutation
  """
  affected_rows: Int!
  """
  data from the rows affected by the mutation
  """
  returning: [User!]!
}

type User_MyUser {
  company_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  status: String
  updated_at: timestamptz
}

input Assessment_aggregate_bool_exp {
  count: Assessment_aggregate_bool_exp_count
}

input Assessment_aggregate_bool_exp_count {
  arguments: [Assessment_select_column!]
  distinct: Boolean
  filter: Assessment_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "Assessment"
"""
input Assessment_aggregate_order_by {
  count: order_by
  max: Assessment_max_order_by
  min: Assessment_min_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input Assessment_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "Assessment"
"""
input Assessment_arr_rel_insert_input {
  data: [Assessment_insert_input!]!
  """
  upsert condition
  """
  on_conflict: Assessment_on_conflict
}

input Assessment_AssessmentQuestion_aggregate_bool_exp {
  count: Assessment_AssessmentQuestion_aggregate_bool_exp_count
}

input Assessment_AssessmentQuestion_aggregate_bool_exp_count {
  arguments: [Assessment_AssessmentQuestion_select_column!]
  distinct: Boolean
  filter: Assessment_AssessmentQuestion_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "Assessment_AssessmentQuestion"
"""
input Assessment_AssessmentQuestion_aggregate_order_by {
  count: order_by
  max: Assessment_AssessmentQuestion_max_order_by
  min: Assessment_AssessmentQuestion_min_order_by
}

"""
input type for inserting array relation for remote table "Assessment_AssessmentQuestion"
"""
input Assessment_AssessmentQuestion_arr_rel_insert_input {
  data: [Assessment_AssessmentQuestion_insert_input!]!
  """
  upsert condition
  """
  on_conflict: Assessment_AssessmentQuestion_on_conflict
}

"""
Boolean expression to filter rows from the table "Assessment_AssessmentQuestion". All fields are combined with a logical 'AND'.
"""
input Assessment_AssessmentQuestion_bool_exp {
  Assessment: Assessment_bool_exp
  Question: AssessmentQuestion_bool_exp
  _and: [Assessment_AssessmentQuestion_bool_exp!]
  _not: Assessment_AssessmentQuestion_bool_exp
  _or: [Assessment_AssessmentQuestion_bool_exp!]
  assessment_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  question_id: uuid_comparison_exp
}

"""
input type for inserting data into table "Assessment_AssessmentQuestion"
"""
input Assessment_AssessmentQuestion_insert_input {
  Assessment: Assessment_obj_rel_insert_input
  Question: AssessmentQuestion_obj_rel_insert_input
  assessment_id: uuid
  created_at: timestamptz
  id: uuid
  question_id: uuid
}

"""
order by max() on columns of table "Assessment_AssessmentQuestion"
"""
input Assessment_AssessmentQuestion_max_order_by {
  assessment_id: order_by
  created_at: order_by
  id: order_by
  question_id: order_by
}

"""
order by min() on columns of table "Assessment_AssessmentQuestion"
"""
input Assessment_AssessmentQuestion_min_order_by {
  assessment_id: order_by
  created_at: order_by
  id: order_by
  question_id: order_by
}

"""
on_conflict condition type for table "Assessment_AssessmentQuestion"
"""
input Assessment_AssessmentQuestion_on_conflict {
  constraint: Assessment_AssessmentQuestion_constraint!
  update_columns: [Assessment_AssessmentQuestion_update_column!]! = []
  where: Assessment_AssessmentQuestion_bool_exp
}

"""
Ordering options when selecting data from "Assessment_AssessmentQuestion".
"""
input Assessment_AssessmentQuestion_order_by {
  Assessment: Assessment_order_by
  Question: AssessmentQuestion_order_by
  assessment_id: order_by
  created_at: order_by
  id: order_by
  question_id: order_by
}

"""
primary key columns input for table: Assessment_AssessmentQuestion
"""
input Assessment_AssessmentQuestion_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "Assessment_AssessmentQuestion"
"""
input Assessment_AssessmentQuestion_set_input {
  assessment_id: uuid
  created_at: timestamptz
  id: uuid
  question_id: uuid
}

"""
Streaming cursor of the table "Assessment_AssessmentQuestion"
"""
input Assessment_AssessmentQuestion_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Assessment_AssessmentQuestion_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Assessment_AssessmentQuestion_stream_cursor_value_input {
  assessment_id: uuid
  created_at: timestamptz
  id: uuid
  question_id: uuid
}

input Assessment_AssessmentQuestion_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Assessment_AssessmentQuestion_set_input
  """
  filter the rows which have to be updated
  """
  where: Assessment_AssessmentQuestion_bool_exp!
}

"""
Boolean expression to filter rows from the table "Assessment". All fields are combined with a logical 'AND'.
"""
input Assessment_bool_exp {
  Candidates: AssessmentCandidate_bool_exp
  Candidates_aggregate: AssessmentCandidate_aggregate_bool_exp
  Company: Company_bool_exp
  Questions: Assessment_AssessmentQuestion_bool_exp
  Questions_aggregate: Assessment_AssessmentQuestion_aggregate_bool_exp
  _and: [Assessment_bool_exp!]
  _not: Assessment_bool_exp
  _or: [Assessment_bool_exp!]
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  difficulty: String_comparison_exp
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  title: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Assessment_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input Assessment_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Assessment_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "Assessment"
"""
input Assessment_insert_input {
  Candidates: AssessmentCandidate_arr_rel_insert_input
  Company: Company_obj_rel_insert_input
  Questions: Assessment_AssessmentQuestion_arr_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  id: uuid
  metadata: jsonb
  title: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "Assessment"
"""
input Assessment_max_order_by {
  company_id: order_by
  created_at: order_by
  description: order_by
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: order_by
  id: order_by
  title: order_by
  updated_at: order_by
}

"""
order by min() on columns of table "Assessment"
"""
input Assessment_min_order_by {
  company_id: order_by
  created_at: order_by
  description: order_by
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: order_by
  id: order_by
  title: order_by
  updated_at: order_by
}

"""
input type for inserting object relation for remote table "Assessment"
"""
input Assessment_obj_rel_insert_input {
  data: Assessment_insert_input!
  """
  upsert condition
  """
  on_conflict: Assessment_on_conflict
}

"""
on_conflict condition type for table "Assessment"
"""
input Assessment_on_conflict {
  constraint: Assessment_constraint!
  update_columns: [Assessment_update_column!]! = []
  where: Assessment_bool_exp
}

"""
Ordering options when selecting data from "Assessment".
"""
input Assessment_order_by {
  Candidates_aggregate: AssessmentCandidate_aggregate_order_by
  Company: Company_order_by
  Questions_aggregate: Assessment_AssessmentQuestion_aggregate_order_by
  company_id: order_by
  created_at: order_by
  description: order_by
  difficulty: order_by
  id: order_by
  metadata: order_by
  title: order_by
  updated_at: order_by
}

"""
primary key columns input for table: Assessment
"""
input Assessment_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input Assessment_prepend_input {
  metadata: jsonb
}

"""
input type for updating data in table "Assessment"
"""
input Assessment_set_input {
  company_id: uuid
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  id: uuid
  metadata: jsonb
  title: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "Assessment"
"""
input Assessment_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Assessment_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Assessment_stream_cursor_value_input {
  company_id: uuid
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  id: uuid
  metadata: jsonb
  title: String
  updated_at: timestamptz
}

input Assessment_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: Assessment_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: Assessment_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: Assessment_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: Assessment_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: Assessment_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Assessment_set_input
  """
  filter the rows which have to be updated
  """
  where: Assessment_bool_exp!
}

input AssessmentCandidate_aggregate_bool_exp {
  count: AssessmentCandidate_aggregate_bool_exp_count
}

input AssessmentCandidate_aggregate_bool_exp_count {
  arguments: [AssessmentCandidate_select_column!]
  distinct: Boolean
  filter: AssessmentCandidate_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "AssessmentCandidate"
"""
input AssessmentCandidate_aggregate_order_by {
  count: order_by
  max: AssessmentCandidate_max_order_by
  min: AssessmentCandidate_min_order_by
}

"""
input type for inserting array relation for remote table "AssessmentCandidate"
"""
input AssessmentCandidate_arr_rel_insert_input {
  data: [AssessmentCandidate_insert_input!]!
  """
  upsert condition
  """
  on_conflict: AssessmentCandidate_on_conflict
}

"""
Boolean expression to filter rows from the table "AssessmentCandidate". All fields are combined with a logical 'AND'.
"""
input AssessmentCandidate_bool_exp {
  Answers: AssessmentCandidateAnswer_bool_exp
  Answers_aggregate: AssessmentCandidateAnswer_aggregate_bool_exp
  Assessment: Assessment_bool_exp
  _and: [AssessmentCandidate_bool_exp!]
  _not: AssessmentCandidate_bool_exp
  _or: [AssessmentCandidate_bool_exp!]
  assessment_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  status: String_comparison_exp
}

"""
input type for inserting data into table "AssessmentCandidate"
"""
input AssessmentCandidate_insert_input {
  Answers: AssessmentCandidateAnswer_arr_rel_insert_input
  Assessment: Assessment_obj_rel_insert_input
  assessment_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  status: String
}

"""
order by max() on columns of table "AssessmentCandidate"
"""
input AssessmentCandidate_max_order_by {
  assessment_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  status: order_by
}

"""
order by min() on columns of table "AssessmentCandidate"
"""
input AssessmentCandidate_min_order_by {
  assessment_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  status: order_by
}

"""
input type for inserting object relation for remote table "AssessmentCandidate"
"""
input AssessmentCandidate_obj_rel_insert_input {
  data: AssessmentCandidate_insert_input!
  """
  upsert condition
  """
  on_conflict: AssessmentCandidate_on_conflict
}

"""
on_conflict condition type for table "AssessmentCandidate"
"""
input AssessmentCandidate_on_conflict {
  constraint: AssessmentCandidate_constraint!
  update_columns: [AssessmentCandidate_update_column!]! = []
  where: AssessmentCandidate_bool_exp
}

"""
Ordering options when selecting data from "AssessmentCandidate".
"""
input AssessmentCandidate_order_by {
  Answers_aggregate: AssessmentCandidateAnswer_aggregate_order_by
  Assessment: Assessment_order_by
  assessment_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  status: order_by
}

"""
primary key columns input for table: AssessmentCandidate
"""
input AssessmentCandidate_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "AssessmentCandidate"
"""
input AssessmentCandidate_set_input {
  assessment_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  status: String
}

"""
Streaming cursor of the table "AssessmentCandidate"
"""
input AssessmentCandidate_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: AssessmentCandidate_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input AssessmentCandidate_stream_cursor_value_input {
  assessment_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  status: String
}

input AssessmentCandidate_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: AssessmentCandidate_set_input
  """
  filter the rows which have to be updated
  """
  where: AssessmentCandidate_bool_exp!
}

input AssessmentCandidateAnswer_aggregate_bool_exp {
  count: AssessmentCandidateAnswer_aggregate_bool_exp_count
}

input AssessmentCandidateAnswer_aggregate_bool_exp_count {
  arguments: [AssessmentCandidateAnswer_select_column!]
  distinct: Boolean
  filter: AssessmentCandidateAnswer_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_aggregate_order_by {
  avg: AssessmentCandidateAnswer_avg_order_by
  count: order_by
  max: AssessmentCandidateAnswer_max_order_by
  min: AssessmentCandidateAnswer_min_order_by
  stddev: AssessmentCandidateAnswer_stddev_order_by
  stddev_pop: AssessmentCandidateAnswer_stddev_pop_order_by
  stddev_samp: AssessmentCandidateAnswer_stddev_samp_order_by
  sum: AssessmentCandidateAnswer_sum_order_by
  var_pop: AssessmentCandidateAnswer_var_pop_order_by
  var_samp: AssessmentCandidateAnswer_var_samp_order_by
  variance: AssessmentCandidateAnswer_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input AssessmentCandidateAnswer_append_input {
  activity_logs: jsonb
  answer: jsonb
  evaluation_details: jsonb
}

"""
input type for inserting array relation for remote table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_arr_rel_insert_input {
  data: [AssessmentCandidateAnswer_insert_input!]!
  """
  upsert condition
  """
  on_conflict: AssessmentCandidateAnswer_on_conflict
}

"""
order by avg() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_avg_order_by {
  score: order_by
}

"""
Boolean expression to filter rows from the table "AssessmentCandidateAnswer". All fields are combined with a logical 'AND'.
"""
input AssessmentCandidateAnswer_bool_exp {
  Candidate: AssessmentCandidate_bool_exp
  Question: AssessmentQuestion_bool_exp
  _and: [AssessmentCandidateAnswer_bool_exp!]
  _not: AssessmentCandidateAnswer_bool_exp
  _or: [AssessmentCandidateAnswer_bool_exp!]
  activity_logs: jsonb_comparison_exp
  answer: jsonb_comparison_exp
  candidate_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  evaluated_at: timestamptz_comparison_exp
  evaluation_details: jsonb_comparison_exp
  id: uuid_comparison_exp
  question_id: uuid_comparison_exp
  score: Int_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AssessmentCandidateAnswer_delete_at_path_input {
  activity_logs: [String!]
  answer: [String!]
  evaluation_details: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AssessmentCandidateAnswer_delete_elem_input {
  activity_logs: Int
  answer: Int
  evaluation_details: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AssessmentCandidateAnswer_delete_key_input {
  activity_logs: String
  answer: String
  evaluation_details: String
}

"""
input type for incrementing numeric columns in table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_inc_input {
  score: Int
}

"""
input type for inserting data into table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_insert_input {
  Candidate: AssessmentCandidate_obj_rel_insert_input
  Question: AssessmentQuestion_obj_rel_insert_input
  activity_logs: jsonb
  answer: jsonb
  candidate_id: uuid
  created_at: timestamptz
  evaluated_at: timestamptz
  evaluation_details: jsonb
  id: uuid
  question_id: uuid
  score: Int
}

"""
order by max() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_max_order_by {
  candidate_id: order_by
  created_at: order_by
  evaluated_at: order_by
  id: order_by
  question_id: order_by
  score: order_by
}

"""
order by min() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_min_order_by {
  candidate_id: order_by
  created_at: order_by
  evaluated_at: order_by
  id: order_by
  question_id: order_by
  score: order_by
}

"""
on_conflict condition type for table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_on_conflict {
  constraint: AssessmentCandidateAnswer_constraint!
  update_columns: [AssessmentCandidateAnswer_update_column!]! = []
  where: AssessmentCandidateAnswer_bool_exp
}

"""
Ordering options when selecting data from "AssessmentCandidateAnswer".
"""
input AssessmentCandidateAnswer_order_by {
  Candidate: AssessmentCandidate_order_by
  Question: AssessmentQuestion_order_by
  activity_logs: order_by
  answer: order_by
  candidate_id: order_by
  created_at: order_by
  evaluated_at: order_by
  evaluation_details: order_by
  id: order_by
  question_id: order_by
  score: order_by
}

"""
primary key columns input for table: AssessmentCandidateAnswer
"""
input AssessmentCandidateAnswer_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input AssessmentCandidateAnswer_prepend_input {
  activity_logs: jsonb
  answer: jsonb
  evaluation_details: jsonb
}

"""
input type for updating data in table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_set_input {
  activity_logs: jsonb
  answer: jsonb
  candidate_id: uuid
  created_at: timestamptz
  evaluated_at: timestamptz
  evaluation_details: jsonb
  id: uuid
  question_id: uuid
  score: Int
}

"""
order by stddev() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_stddev_order_by {
  score: order_by
}

"""
order by stddev_pop() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_stddev_pop_order_by {
  score: order_by
}

"""
order by stddev_samp() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_stddev_samp_order_by {
  score: order_by
}

"""
Streaming cursor of the table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: AssessmentCandidateAnswer_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input AssessmentCandidateAnswer_stream_cursor_value_input {
  activity_logs: jsonb
  answer: jsonb
  candidate_id: uuid
  created_at: timestamptz
  evaluated_at: timestamptz
  evaluation_details: jsonb
  id: uuid
  question_id: uuid
  score: Int
}

"""
order by sum() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_sum_order_by {
  score: order_by
}

input AssessmentCandidateAnswer_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: AssessmentCandidateAnswer_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: AssessmentCandidateAnswer_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: AssessmentCandidateAnswer_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: AssessmentCandidateAnswer_delete_key_input
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: AssessmentCandidateAnswer_inc_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: AssessmentCandidateAnswer_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: AssessmentCandidateAnswer_set_input
  """
  filter the rows which have to be updated
  """
  where: AssessmentCandidateAnswer_bool_exp!
}

"""
order by var_pop() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_var_pop_order_by {
  score: order_by
}

"""
order by var_samp() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_var_samp_order_by {
  score: order_by
}

"""
order by variance() on columns of table "AssessmentCandidateAnswer"
"""
input AssessmentCandidateAnswer_variance_order_by {
  score: order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input AssessmentQuestion_append_input {
  config: jsonb
}

"""
Boolean expression to filter rows from the table "AssessmentQuestion". All fields are combined with a logical 'AND'.
"""
input AssessmentQuestion_bool_exp {
  Assessments: Assessment_AssessmentQuestion_bool_exp
  Assessments_aggregate: Assessment_AssessmentQuestion_aggregate_bool_exp
  Company: Company_bool_exp
  Skills: AssessmentQuestion_Skill_bool_exp
  Skills_aggregate: AssessmentQuestion_Skill_aggregate_bool_exp
  _and: [AssessmentQuestion_bool_exp!]
  _not: AssessmentQuestion_bool_exp
  _or: [AssessmentQuestion_bool_exp!]
  company_id: uuid_comparison_exp
  config: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  difficulty: String_comparison_exp
  duration: Int_comparison_exp
  id: uuid_comparison_exp
  title: String_comparison_exp
  type: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input AssessmentQuestion_delete_at_path_input {
  config: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input AssessmentQuestion_delete_elem_input {
  config: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input AssessmentQuestion_delete_key_input {
  config: String
}

"""
input type for incrementing numeric columns in table "AssessmentQuestion"
"""
input AssessmentQuestion_inc_input {
  duration: Int
}

"""
input type for inserting data into table "AssessmentQuestion"
"""
input AssessmentQuestion_insert_input {
  Assessments: Assessment_AssessmentQuestion_arr_rel_insert_input
  Company: Company_obj_rel_insert_input
  Skills: AssessmentQuestion_Skill_arr_rel_insert_input
  company_id: uuid
  config: jsonb
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  duration: Int
  id: uuid
  title: String
  """
  Enum type: "Coding" | "Video" | "MCQ" | "OpenEnded" | "CodingRealtime" | "OpenEndedRealtime"
  """
  type: String
  updated_at: timestamptz
}

"""
input type for inserting object relation for remote table "AssessmentQuestion"
"""
input AssessmentQuestion_obj_rel_insert_input {
  data: AssessmentQuestion_insert_input!
  """
  upsert condition
  """
  on_conflict: AssessmentQuestion_on_conflict
}

"""
on_conflict condition type for table "AssessmentQuestion"
"""
input AssessmentQuestion_on_conflict {
  constraint: AssessmentQuestion_constraint!
  update_columns: [AssessmentQuestion_update_column!]! = []
  where: AssessmentQuestion_bool_exp
}

"""
Ordering options when selecting data from "AssessmentQuestion".
"""
input AssessmentQuestion_order_by {
  Assessments_aggregate: Assessment_AssessmentQuestion_aggregate_order_by
  Company: Company_order_by
  Skills_aggregate: AssessmentQuestion_Skill_aggregate_order_by
  company_id: order_by
  config: order_by
  created_at: order_by
  description: order_by
  difficulty: order_by
  duration: order_by
  id: order_by
  title: order_by
  type: order_by
  updated_at: order_by
}

"""
primary key columns input for table: AssessmentQuestion
"""
input AssessmentQuestion_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input AssessmentQuestion_prepend_input {
  config: jsonb
}

"""
input type for updating data in table "AssessmentQuestion"
"""
input AssessmentQuestion_set_input {
  company_id: uuid
  config: jsonb
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  duration: Int
  id: uuid
  title: String
  """
  Enum type: "Coding" | "Video" | "MCQ" | "OpenEnded" | "CodingRealtime" | "OpenEndedRealtime"
  """
  type: String
  updated_at: timestamptz
}

input AssessmentQuestion_Skill_aggregate_bool_exp {
  count: AssessmentQuestion_Skill_aggregate_bool_exp_count
}

input AssessmentQuestion_Skill_aggregate_bool_exp_count {
  arguments: [AssessmentQuestion_Skill_select_column!]
  distinct: Boolean
  filter: AssessmentQuestion_Skill_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "AssessmentQuestion_Skill"
"""
input AssessmentQuestion_Skill_aggregate_order_by {
  count: order_by
  max: AssessmentQuestion_Skill_max_order_by
  min: AssessmentQuestion_Skill_min_order_by
}

"""
input type for inserting array relation for remote table "AssessmentQuestion_Skill"
"""
input AssessmentQuestion_Skill_arr_rel_insert_input {
  data: [AssessmentQuestion_Skill_insert_input!]!
  """
  upsert condition
  """
  on_conflict: AssessmentQuestion_Skill_on_conflict
}

"""
Boolean expression to filter rows from the table "AssessmentQuestion_Skill". All fields are combined with a logical 'AND'.
"""
input AssessmentQuestion_Skill_bool_exp {
  Question: AssessmentQuestion_bool_exp
  Skill: Skill_bool_exp
  _and: [AssessmentQuestion_Skill_bool_exp!]
  _not: AssessmentQuestion_Skill_bool_exp
  _or: [AssessmentQuestion_Skill_bool_exp!]
  id: uuid_comparison_exp
  question_id: uuid_comparison_exp
  skill_id: uuid_comparison_exp
}

"""
input type for inserting data into table "AssessmentQuestion_Skill"
"""
input AssessmentQuestion_Skill_insert_input {
  Question: AssessmentQuestion_obj_rel_insert_input
  Skill: Skill_obj_rel_insert_input
  id: uuid
  question_id: uuid
  skill_id: uuid
}

"""
order by max() on columns of table "AssessmentQuestion_Skill"
"""
input AssessmentQuestion_Skill_max_order_by {
  id: order_by
  question_id: order_by
  skill_id: order_by
}

"""
order by min() on columns of table "AssessmentQuestion_Skill"
"""
input AssessmentQuestion_Skill_min_order_by {
  id: order_by
  question_id: order_by
  skill_id: order_by
}

"""
on_conflict condition type for table "AssessmentQuestion_Skill"
"""
input AssessmentQuestion_Skill_on_conflict {
  constraint: AssessmentQuestion_Skill_constraint!
  update_columns: [AssessmentQuestion_Skill_update_column!]! = []
  where: AssessmentQuestion_Skill_bool_exp
}

"""
Ordering options when selecting data from "AssessmentQuestion_Skill".
"""
input AssessmentQuestion_Skill_order_by {
  Question: AssessmentQuestion_order_by
  Skill: Skill_order_by
  id: order_by
  question_id: order_by
  skill_id: order_by
}

"""
primary key columns input for table: AssessmentQuestion_Skill
"""
input AssessmentQuestion_Skill_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "AssessmentQuestion_Skill"
"""
input AssessmentQuestion_Skill_set_input {
  id: uuid
  question_id: uuid
  skill_id: uuid
}

"""
Streaming cursor of the table "AssessmentQuestion_Skill"
"""
input AssessmentQuestion_Skill_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: AssessmentQuestion_Skill_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input AssessmentQuestion_Skill_stream_cursor_value_input {
  id: uuid
  question_id: uuid
  skill_id: uuid
}

input AssessmentQuestion_Skill_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: AssessmentQuestion_Skill_set_input
  """
  filter the rows which have to be updated
  """
  where: AssessmentQuestion_Skill_bool_exp!
}

"""
Streaming cursor of the table "AssessmentQuestion"
"""
input AssessmentQuestion_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: AssessmentQuestion_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input AssessmentQuestion_stream_cursor_value_input {
  company_id: uuid
  config: jsonb
  created_at: timestamptz
  description: String
  """
  Enum type: "Easy" | "Medium" | "Hard"
  """
  difficulty: String
  duration: Int
  id: uuid
  title: String
  """
  Enum type: "Coding" | "Video" | "MCQ" | "OpenEnded" | "CodingRealtime" | "OpenEndedRealtime"
  """
  type: String
  updated_at: timestamptz
}

input AssessmentQuestion_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: AssessmentQuestion_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: AssessmentQuestion_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: AssessmentQuestion_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: AssessmentQuestion_delete_key_input
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: AssessmentQuestion_inc_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: AssessmentQuestion_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: AssessmentQuestion_set_input
  """
  filter the rows which have to be updated
  """
  where: AssessmentQuestion_bool_exp!
}

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

input Candidate_aggregate_bool_exp {
  avg: Candidate_aggregate_bool_exp_avg
  corr: Candidate_aggregate_bool_exp_corr
  count: Candidate_aggregate_bool_exp_count
  covar_samp: Candidate_aggregate_bool_exp_covar_samp
  max: Candidate_aggregate_bool_exp_max
  min: Candidate_aggregate_bool_exp_min
  stddev_samp: Candidate_aggregate_bool_exp_stddev_samp
  sum: Candidate_aggregate_bool_exp_sum
  var_samp: Candidate_aggregate_bool_exp_var_samp
}

input Candidate_aggregate_bool_exp_avg {
  arguments: Candidate_select_column_Candidate_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: float8_comparison_exp!
}

input Candidate_aggregate_bool_exp_corr {
  arguments: Candidate_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: float8_comparison_exp!
}

input Candidate_aggregate_bool_exp_corr_arguments {
  X: Candidate_select_column_Candidate_aggregate_bool_exp_corr_arguments_columns!
  Y: Candidate_select_column_Candidate_aggregate_bool_exp_corr_arguments_columns!
}

input Candidate_aggregate_bool_exp_count {
  arguments: [Candidate_select_column!]
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: Int_comparison_exp!
}

input Candidate_aggregate_bool_exp_covar_samp {
  arguments: Candidate_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: float8_comparison_exp!
}

input Candidate_aggregate_bool_exp_covar_samp_arguments {
  X: Candidate_select_column_Candidate_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: Candidate_select_column_Candidate_aggregate_bool_exp_covar_samp_arguments_columns!
}

input Candidate_aggregate_bool_exp_max {
  arguments: Candidate_select_column_Candidate_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: float8_comparison_exp!
}

input Candidate_aggregate_bool_exp_min {
  arguments: Candidate_select_column_Candidate_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: float8_comparison_exp!
}

input Candidate_aggregate_bool_exp_stddev_samp {
  arguments: Candidate_select_column_Candidate_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: float8_comparison_exp!
}

input Candidate_aggregate_bool_exp_sum {
  arguments: Candidate_select_column_Candidate_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: float8_comparison_exp!
}

input Candidate_aggregate_bool_exp_var_samp {
  arguments: Candidate_select_column_Candidate_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: Candidate_bool_exp
  predicate: float8_comparison_exp!
}

"""
order by aggregate values of table "Candidate"
"""
input Candidate_aggregate_order_by {
  avg: Candidate_avg_order_by
  count: order_by
  max: Candidate_max_order_by
  min: Candidate_min_order_by
  stddev: Candidate_stddev_order_by
  stddev_pop: Candidate_stddev_pop_order_by
  stddev_samp: Candidate_stddev_samp_order_by
  sum: Candidate_sum_order_by
  var_pop: Candidate_var_pop_order_by
  var_samp: Candidate_var_samp_order_by
  variance: Candidate_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input Candidate_append_input {
  application_metadata: jsonb
}

"""
input type for inserting array relation for remote table "Candidate"
"""
input Candidate_arr_rel_insert_input {
  data: [Candidate_insert_input!]!
  """
  upsert condition
  """
  on_conflict: Candidate_on_conflict
}

"""
order by avg() on columns of table "Candidate"
"""
input Candidate_avg_order_by {
  total_score: order_by
}

"""
Boolean expression to filter rows from the table "Candidate". All fields are combined with a logical 'AND'.
"""
input Candidate_bool_exp {
  Conversations: Conversation_bool_exp
  Conversations_aggregate: Conversation_aggregate_bool_exp
  CurrentNode: PipelineNode_bool_exp
  NodeResponses: CandidateNodeResponse_bool_exp
  NodeResponses_aggregate: CandidateNodeResponse_aggregate_bool_exp
  Pipeline: Pipeline_bool_exp
  _and: [Candidate_bool_exp!]
  _not: Candidate_bool_exp
  _or: [Candidate_bool_exp!]
  application_metadata: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  current_node_id: uuid_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  pipeline_id: uuid_comparison_exp
  resume_url: String_comparison_exp
  status: String_comparison_exp
  total_score: float8_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Candidate_delete_at_path_input {
  application_metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input Candidate_delete_elem_input {
  application_metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Candidate_delete_key_input {
  application_metadata: String
}

"""
input type for incrementing numeric columns in table "Candidate"
"""
input Candidate_inc_input {
  total_score: float8
}

"""
input type for inserting data into table "Candidate"
"""
input Candidate_insert_input {
  Conversations: Conversation_arr_rel_insert_input
  CurrentNode: PipelineNode_obj_rel_insert_input
  NodeResponses: CandidateNodeResponse_arr_rel_insert_input
  Pipeline: Pipeline_obj_rel_insert_input
  application_metadata: jsonb
  created_at: timestamptz
  current_node_id: uuid
  email: String
  id: uuid
  name: String
  pipeline_id: uuid
  resume_url: String
  status: String
  total_score: float8
}

"""
order by max() on columns of table "Candidate"
"""
input Candidate_max_order_by {
  created_at: order_by
  current_node_id: order_by
  email: order_by
  id: order_by
  name: order_by
  pipeline_id: order_by
  resume_url: order_by
  status: order_by
  total_score: order_by
}

"""
order by min() on columns of table "Candidate"
"""
input Candidate_min_order_by {
  created_at: order_by
  current_node_id: order_by
  email: order_by
  id: order_by
  name: order_by
  pipeline_id: order_by
  resume_url: order_by
  status: order_by
  total_score: order_by
}

"""
input type for inserting object relation for remote table "Candidate"
"""
input Candidate_obj_rel_insert_input {
  data: Candidate_insert_input!
  """
  upsert condition
  """
  on_conflict: Candidate_on_conflict
}

"""
on_conflict condition type for table "Candidate"
"""
input Candidate_on_conflict {
  constraint: Candidate_constraint!
  update_columns: [Candidate_update_column!]! = []
  where: Candidate_bool_exp
}

"""
Ordering options when selecting data from "Candidate".
"""
input Candidate_order_by {
  Conversations_aggregate: Conversation_aggregate_order_by
  CurrentNode: PipelineNode_order_by
  NodeResponses_aggregate: CandidateNodeResponse_aggregate_order_by
  Pipeline: Pipeline_order_by
  application_metadata: order_by
  created_at: order_by
  current_node_id: order_by
  email: order_by
  id: order_by
  name: order_by
  pipeline_id: order_by
  resume_url: order_by
  status: order_by
  total_score: order_by
}

"""
primary key columns input for table: Candidate
"""
input Candidate_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input Candidate_prepend_input {
  application_metadata: jsonb
}

"""
input type for updating data in table "Candidate"
"""
input Candidate_set_input {
  application_metadata: jsonb
  created_at: timestamptz
  current_node_id: uuid
  email: String
  id: uuid
  name: String
  pipeline_id: uuid
  resume_url: String
  status: String
  total_score: float8
}

"""
order by stddev() on columns of table "Candidate"
"""
input Candidate_stddev_order_by {
  total_score: order_by
}

"""
order by stddev_pop() on columns of table "Candidate"
"""
input Candidate_stddev_pop_order_by {
  total_score: order_by
}

"""
order by stddev_samp() on columns of table "Candidate"
"""
input Candidate_stddev_samp_order_by {
  total_score: order_by
}

"""
Streaming cursor of the table "Candidate"
"""
input Candidate_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Candidate_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Candidate_stream_cursor_value_input {
  application_metadata: jsonb
  created_at: timestamptz
  current_node_id: uuid
  email: String
  id: uuid
  name: String
  pipeline_id: uuid
  resume_url: String
  status: String
  total_score: float8
}

"""
order by sum() on columns of table "Candidate"
"""
input Candidate_sum_order_by {
  total_score: order_by
}

input Candidate_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: Candidate_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: Candidate_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: Candidate_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: Candidate_delete_key_input
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: Candidate_inc_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: Candidate_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Candidate_set_input
  """
  filter the rows which have to be updated
  """
  where: Candidate_bool_exp!
}

"""
order by var_pop() on columns of table "Candidate"
"""
input Candidate_var_pop_order_by {
  total_score: order_by
}

"""
order by var_samp() on columns of table "Candidate"
"""
input Candidate_var_samp_order_by {
  total_score: order_by
}

"""
order by variance() on columns of table "Candidate"
"""
input Candidate_variance_order_by {
  total_score: order_by
}

input CandidateNodeResponse_aggregate_bool_exp {
  avg: CandidateNodeResponse_aggregate_bool_exp_avg
  corr: CandidateNodeResponse_aggregate_bool_exp_corr
  count: CandidateNodeResponse_aggregate_bool_exp_count
  covar_samp: CandidateNodeResponse_aggregate_bool_exp_covar_samp
  max: CandidateNodeResponse_aggregate_bool_exp_max
  min: CandidateNodeResponse_aggregate_bool_exp_min
  stddev_samp: CandidateNodeResponse_aggregate_bool_exp_stddev_samp
  sum: CandidateNodeResponse_aggregate_bool_exp_sum
  var_samp: CandidateNodeResponse_aggregate_bool_exp_var_samp
}

input CandidateNodeResponse_aggregate_bool_exp_avg {
  arguments: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: float8_comparison_exp!
}

input CandidateNodeResponse_aggregate_bool_exp_corr {
  arguments: CandidateNodeResponse_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: float8_comparison_exp!
}

input CandidateNodeResponse_aggregate_bool_exp_corr_arguments {
  X: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_corr_arguments_columns!
  Y: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_corr_arguments_columns!
}

input CandidateNodeResponse_aggregate_bool_exp_count {
  arguments: [CandidateNodeResponse_select_column!]
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: Int_comparison_exp!
}

input CandidateNodeResponse_aggregate_bool_exp_covar_samp {
  arguments: CandidateNodeResponse_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: float8_comparison_exp!
}

input CandidateNodeResponse_aggregate_bool_exp_covar_samp_arguments {
  X: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_covar_samp_arguments_columns!
}

input CandidateNodeResponse_aggregate_bool_exp_max {
  arguments: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: float8_comparison_exp!
}

input CandidateNodeResponse_aggregate_bool_exp_min {
  arguments: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: float8_comparison_exp!
}

input CandidateNodeResponse_aggregate_bool_exp_stddev_samp {
  arguments: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: float8_comparison_exp!
}

input CandidateNodeResponse_aggregate_bool_exp_sum {
  arguments: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: float8_comparison_exp!
}

input CandidateNodeResponse_aggregate_bool_exp_var_samp {
  arguments: CandidateNodeResponse_select_column_CandidateNodeResponse_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: CandidateNodeResponse_bool_exp
  predicate: float8_comparison_exp!
}

"""
order by aggregate values of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_aggregate_order_by {
  avg: CandidateNodeResponse_avg_order_by
  count: order_by
  max: CandidateNodeResponse_max_order_by
  min: CandidateNodeResponse_min_order_by
  stddev: CandidateNodeResponse_stddev_order_by
  stddev_pop: CandidateNodeResponse_stddev_pop_order_by
  stddev_samp: CandidateNodeResponse_stddev_samp_order_by
  sum: CandidateNodeResponse_sum_order_by
  var_pop: CandidateNodeResponse_var_pop_order_by
  var_samp: CandidateNodeResponse_var_samp_order_by
  variance: CandidateNodeResponse_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input CandidateNodeResponse_append_input {
  response: jsonb
  result: jsonb
}

"""
input type for inserting array relation for remote table "CandidateNodeResponse"
"""
input CandidateNodeResponse_arr_rel_insert_input {
  data: [CandidateNodeResponse_insert_input!]!
  """
  upsert condition
  """
  on_conflict: CandidateNodeResponse_on_conflict
}

"""
order by avg() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_avg_order_by {
  score: order_by
}

"""
Boolean expression to filter rows from the table "CandidateNodeResponse". All fields are combined with a logical 'AND'.
"""
input CandidateNodeResponse_bool_exp {
  Candidate: Candidate_bool_exp
  PipelineNode: PipelineNode_bool_exp
  _and: [CandidateNodeResponse_bool_exp!]
  _not: CandidateNodeResponse_bool_exp
  _or: [CandidateNodeResponse_bool_exp!]
  candidate_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  node_id: uuid_comparison_exp
  response: jsonb_comparison_exp
  result: jsonb_comparison_exp
  score: float8_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input CandidateNodeResponse_delete_at_path_input {
  response: [String!]
  result: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input CandidateNodeResponse_delete_elem_input {
  response: Int
  result: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input CandidateNodeResponse_delete_key_input {
  response: String
  result: String
}

"""
input type for incrementing numeric columns in table "CandidateNodeResponse"
"""
input CandidateNodeResponse_inc_input {
  score: float8
}

"""
input type for inserting data into table "CandidateNodeResponse"
"""
input CandidateNodeResponse_insert_input {
  Candidate: Candidate_obj_rel_insert_input
  PipelineNode: PipelineNode_obj_rel_insert_input
  candidate_id: uuid
  created_at: timestamptz
  id: uuid
  node_id: uuid
  response: jsonb
  result: jsonb
  score: float8
}

"""
order by max() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_max_order_by {
  candidate_id: order_by
  created_at: order_by
  id: order_by
  node_id: order_by
  score: order_by
}

"""
order by min() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_min_order_by {
  candidate_id: order_by
  created_at: order_by
  id: order_by
  node_id: order_by
  score: order_by
}

"""
on_conflict condition type for table "CandidateNodeResponse"
"""
input CandidateNodeResponse_on_conflict {
  constraint: CandidateNodeResponse_constraint!
  update_columns: [CandidateNodeResponse_update_column!]! = []
  where: CandidateNodeResponse_bool_exp
}

"""
Ordering options when selecting data from "CandidateNodeResponse".
"""
input CandidateNodeResponse_order_by {
  Candidate: Candidate_order_by
  PipelineNode: PipelineNode_order_by
  candidate_id: order_by
  created_at: order_by
  id: order_by
  node_id: order_by
  response: order_by
  result: order_by
  score: order_by
}

"""
primary key columns input for table: CandidateNodeResponse
"""
input CandidateNodeResponse_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input CandidateNodeResponse_prepend_input {
  response: jsonb
  result: jsonb
}

"""
input type for updating data in table "CandidateNodeResponse"
"""
input CandidateNodeResponse_set_input {
  candidate_id: uuid
  created_at: timestamptz
  id: uuid
  node_id: uuid
  response: jsonb
  result: jsonb
  score: float8
}

"""
order by stddev() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_stddev_order_by {
  score: order_by
}

"""
order by stddev_pop() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_stddev_pop_order_by {
  score: order_by
}

"""
order by stddev_samp() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_stddev_samp_order_by {
  score: order_by
}

"""
Streaming cursor of the table "CandidateNodeResponse"
"""
input CandidateNodeResponse_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: CandidateNodeResponse_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input CandidateNodeResponse_stream_cursor_value_input {
  candidate_id: uuid
  created_at: timestamptz
  id: uuid
  node_id: uuid
  response: jsonb
  result: jsonb
  score: float8
}

"""
order by sum() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_sum_order_by {
  score: order_by
}

input CandidateNodeResponse_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: CandidateNodeResponse_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: CandidateNodeResponse_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: CandidateNodeResponse_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: CandidateNodeResponse_delete_key_input
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: CandidateNodeResponse_inc_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: CandidateNodeResponse_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: CandidateNodeResponse_set_input
  """
  filter the rows which have to be updated
  """
  where: CandidateNodeResponse_bool_exp!
}

"""
order by var_pop() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_var_pop_order_by {
  score: order_by
}

"""
order by var_samp() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_var_samp_order_by {
  score: order_by
}

"""
order by variance() on columns of table "CandidateNodeResponse"
"""
input CandidateNodeResponse_variance_order_by {
  score: order_by
}

input ChangePasswordInput {
  newPassword: String!
  oldPassword: String!
  userId: String!
}

input CheckoutSessionInput {
  amount: float8!
}

"""
Boolean expression to filter rows from the table "Company". All fields are combined with a logical 'AND'.
"""
input Company_bool_exp {
  Assessments: Assessment_bool_exp
  Assessments_aggregate: Assessment_aggregate_bool_exp
  Conversations: Conversation_bool_exp
  Conversations_aggregate: Conversation_aggregate_bool_exp
  Members: User_bool_exp
  Members_aggregate: User_aggregate_bool_exp
  Pipelines: Pipeline_bool_exp
  Pipelines_aggregate: Pipeline_aggregate_bool_exp
  Transactions: Transaction_bool_exp
  Transactions_aggregate: Transaction_aggregate_bool_exp
  _and: [Company_bool_exp!]
  _not: Company_bool_exp
  _or: [Company_bool_exp!]
  ashby_api_key: String_comparison_exp
  cover_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  credits: float8_comparison_exp
  display_assessment_score: Boolean_comparison_exp
  display_pipeline_info: Boolean_comparison_exp
  greenhouse_api_key: String_comparison_exp
  id: uuid_comparison_exp
  logo_url: String_comparison_exp
  name: String_comparison_exp
  slug: String_comparison_exp
  zapier_access_token: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "Company"
"""
input Company_inc_input {
  credits: float8
}

"""
input type for inserting data into table "Company"
"""
input Company_insert_input {
  Assessments: Assessment_arr_rel_insert_input
  Conversations: Conversation_arr_rel_insert_input
  Members: User_arr_rel_insert_input
  Pipelines: Pipeline_arr_rel_insert_input
  Transactions: Transaction_arr_rel_insert_input
  ashby_api_key: String
  cover_url: String
  created_at: timestamptz
  credits: float8
  display_assessment_score: Boolean
  display_pipeline_info: Boolean
  greenhouse_api_key: String
  id: uuid
  logo_url: String
  name: String
  slug: String
  zapier_access_token: String
}

"""
input type for inserting object relation for remote table "Company"
"""
input Company_obj_rel_insert_input {
  data: Company_insert_input!
  """
  upsert condition
  """
  on_conflict: Company_on_conflict
}

"""
on_conflict condition type for table "Company"
"""
input Company_on_conflict {
  constraint: Company_constraint!
  update_columns: [Company_update_column!]! = []
  where: Company_bool_exp
}

"""
Ordering options when selecting data from "Company".
"""
input Company_order_by {
  Assessments_aggregate: Assessment_aggregate_order_by
  Conversations_aggregate: Conversation_aggregate_order_by
  Members_aggregate: User_aggregate_order_by
  Pipelines_aggregate: Pipeline_aggregate_order_by
  Transactions_aggregate: Transaction_aggregate_order_by
  ashby_api_key: order_by
  cover_url: order_by
  created_at: order_by
  credits: order_by
  display_assessment_score: order_by
  display_pipeline_info: order_by
  greenhouse_api_key: order_by
  id: order_by
  logo_url: order_by
  name: order_by
  slug: order_by
  zapier_access_token: order_by
}

"""
primary key columns input for table: Company
"""
input Company_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "Company"
"""
input Company_set_input {
  ashby_api_key: String
  cover_url: String
  created_at: timestamptz
  credits: float8
  display_assessment_score: Boolean
  display_pipeline_info: Boolean
  greenhouse_api_key: String
  id: uuid
  logo_url: String
  name: String
  slug: String
  zapier_access_token: String
}

"""
Streaming cursor of the table "Company"
"""
input Company_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Company_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Company_stream_cursor_value_input {
  ashby_api_key: String
  cover_url: String
  created_at: timestamptz
  credits: float8
  display_assessment_score: Boolean
  display_pipeline_info: Boolean
  greenhouse_api_key: String
  id: uuid
  logo_url: String
  name: String
  slug: String
  zapier_access_token: String
}

input Company_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: Company_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Company_set_input
  """
  filter the rows which have to be updated
  """
  where: Company_bool_exp!
}

input Conversation_aggregate_bool_exp {
  count: Conversation_aggregate_bool_exp_count
}

input Conversation_aggregate_bool_exp_count {
  arguments: [Conversation_select_column!]
  distinct: Boolean
  filter: Conversation_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "Conversation"
"""
input Conversation_aggregate_order_by {
  count: order_by
  max: Conversation_max_order_by
  min: Conversation_min_order_by
}

"""
input type for inserting array relation for remote table "Conversation"
"""
input Conversation_arr_rel_insert_input {
  data: [Conversation_insert_input!]!
  """
  upsert condition
  """
  on_conflict: Conversation_on_conflict
}

"""
Boolean expression to filter rows from the table "Conversation". All fields are combined with a logical 'AND'.
"""
input Conversation_bool_exp {
  Candidate: Candidate_bool_exp
  Company: Company_bool_exp
  Messages: Message_bool_exp
  Messages_aggregate: Message_aggregate_bool_exp
  _and: [Conversation_bool_exp!]
  _not: Conversation_bool_exp
  _or: [Conversation_bool_exp!]
  candidate_id: uuid_comparison_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
}

"""
input type for inserting data into table "Conversation"
"""
input Conversation_insert_input {
  Candidate: Candidate_obj_rel_insert_input
  Company: Company_obj_rel_insert_input
  Messages: Message_arr_rel_insert_input
  candidate_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
}

"""
order by max() on columns of table "Conversation"
"""
input Conversation_max_order_by {
  candidate_id: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
}

"""
order by min() on columns of table "Conversation"
"""
input Conversation_min_order_by {
  candidate_id: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
}

"""
on_conflict condition type for table "Conversation"
"""
input Conversation_on_conflict {
  constraint: Conversation_constraint!
  update_columns: [Conversation_update_column!]! = []
  where: Conversation_bool_exp
}

"""
Ordering options when selecting data from "Conversation".
"""
input Conversation_order_by {
  Candidate: Candidate_order_by
  Company: Company_order_by
  Messages_aggregate: Message_aggregate_order_by
  candidate_id: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
}

"""
primary key columns input for table: Conversation
"""
input Conversation_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "Conversation"
"""
input Conversation_set_input {
  candidate_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
}

"""
Streaming cursor of the table "Conversation"
"""
input Conversation_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Conversation_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Conversation_stream_cursor_value_input {
  candidate_id: uuid
  company_id: uuid
  created_at: timestamptz
  id: uuid
}

input Conversation_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Conversation_set_input
  """
  filter the rows which have to be updated
  """
  where: Conversation_bool_exp!
}

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

input ForgotPasswordInput {
  email: String!
}

input GeneratePipelineInput {
  jobCriteria: jsonb!
}

input GoogleAuthInput {
  googleAccessToken: String!
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

input InviteCompanyMemberInput {
  email: String!
}

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  """
  is the column contained in the given json value
  """
  _contained_in: jsonb
  """
  does the column contain the given json value at the top level
  """
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  """
  does the string exist as a top-level key in the column
  """
  _has_key: String
  """
  do all of these strings exist as top-level keys in the column
  """
  _has_keys_all: [String!]
  """
  do any of these strings exist as top-level keys in the column
  """
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

input LoginInput {
  email: String!
  password: String!
}

input Message_aggregate_bool_exp {
  count: Message_aggregate_bool_exp_count
}

input Message_aggregate_bool_exp_count {
  arguments: [Message_select_column!]
  distinct: Boolean
  filter: Message_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "Message"
"""
input Message_aggregate_order_by {
  count: order_by
  max: Message_max_order_by
  min: Message_min_order_by
}

"""
input type for inserting array relation for remote table "Message"
"""
input Message_arr_rel_insert_input {
  data: [Message_insert_input!]!
  """
  upsert condition
  """
  on_conflict: Message_on_conflict
}

"""
Boolean expression to filter rows from the table "Message". All fields are combined with a logical 'AND'.
"""
input Message_bool_exp {
  _and: [Message_bool_exp!]
  _not: Message_bool_exp
  _or: [Message_bool_exp!]
  content: String_comparison_exp
  conversation_id: uuid_comparison_exp
  id: uuid_comparison_exp
  sender_id: uuid_comparison_exp
  sent_at: timestamptz_comparison_exp
}

"""
input type for inserting data into table "Message"
"""
input Message_insert_input {
  content: String
  conversation_id: uuid
  id: uuid
  sender_id: uuid
  sent_at: timestamptz
}

"""
order by max() on columns of table "Message"
"""
input Message_max_order_by {
  content: order_by
  conversation_id: order_by
  id: order_by
  sender_id: order_by
  sent_at: order_by
}

"""
order by min() on columns of table "Message"
"""
input Message_min_order_by {
  content: order_by
  conversation_id: order_by
  id: order_by
  sender_id: order_by
  sent_at: order_by
}

"""
on_conflict condition type for table "Message"
"""
input Message_on_conflict {
  constraint: Message_constraint!
  update_columns: [Message_update_column!]! = []
  where: Message_bool_exp
}

"""
Ordering options when selecting data from "Message".
"""
input Message_order_by {
  content: order_by
  conversation_id: order_by
  id: order_by
  sender_id: order_by
  sent_at: order_by
}

"""
primary key columns input for table: Message
"""
input Message_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "Message"
"""
input Message_set_input {
  content: String
  conversation_id: uuid
  id: uuid
  sender_id: uuid
  sent_at: timestamptz
}

"""
Streaming cursor of the table "Message"
"""
input Message_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Message_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Message_stream_cursor_value_input {
  content: String
  conversation_id: uuid
  id: uuid
  sender_id: uuid
  sent_at: timestamptz
}

input Message_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Message_set_input
  """
  filter the rows which have to be updated
  """
  where: Message_bool_exp!
}

"""
Boolean expression to filter rows from the table "NodeLogs". All fields are combined with a logical 'AND'.
"""
input NodeLogs_bool_exp {
  Candidate: Candidate_bool_exp
  Node: PipelineNode_bool_exp
  _and: [NodeLogs_bool_exp!]
  _not: NodeLogs_bool_exp
  _or: [NodeLogs_bool_exp!]
  candidate_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  duration_seconds: bigint_comparison_exp
  error_message: String_comparison_exp
  id: uuid_comparison_exp
  node_id: uuid_comparison_exp
  notes: String_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
input type for inserting data into table "NodeLogs"
"""
input NodeLogs_insert_input {
  Candidate: Candidate_obj_rel_insert_input
  Node: PipelineNode_obj_rel_insert_input
  candidate_id: uuid
  created_at: timestamptz
  error_message: String
  id: uuid
  node_id: uuid
  notes: String
  """
  enum type: "pending" | "error" | "success"
  """
  status: String
  updated_at: timestamptz
}

"""
on_conflict condition type for table "NodeLogs"
"""
input NodeLogs_on_conflict {
  constraint: NodeLogs_constraint!
  update_columns: [NodeLogs_update_column!]! = []
  where: NodeLogs_bool_exp
}

"""
Ordering options when selecting data from "NodeLogs".
"""
input NodeLogs_order_by {
  Candidate: Candidate_order_by
  Node: PipelineNode_order_by
  candidate_id: order_by
  created_at: order_by
  duration_seconds: order_by
  error_message: order_by
  id: order_by
  node_id: order_by
  notes: order_by
  status: order_by
  updated_at: order_by
}

"""
primary key columns input for table: NodeLogs
"""
input NodeLogs_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "NodeLogs"
"""
input NodeLogs_set_input {
  candidate_id: uuid
  created_at: timestamptz
  error_message: String
  id: uuid
  node_id: uuid
  notes: String
  """
  enum type: "pending" | "error" | "success"
  """
  status: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "NodeLogs"
"""
input NodeLogs_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: NodeLogs_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input NodeLogs_stream_cursor_value_input {
  candidate_id: uuid
  created_at: timestamptz
  error_message: String
  id: uuid
  node_id: uuid
  notes: String
  """
  enum type: "pending" | "error" | "success"
  """
  status: String
  updated_at: timestamptz
}

input NodeLogs_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: NodeLogs_set_input
  """
  filter the rows which have to be updated
  """
  where: NodeLogs_bool_exp!
}

input Pipeline_aggregate_bool_exp {
  bool_and: Pipeline_aggregate_bool_exp_bool_and
  bool_or: Pipeline_aggregate_bool_exp_bool_or
  count: Pipeline_aggregate_bool_exp_count
}

input Pipeline_aggregate_bool_exp_bool_and {
  arguments: Pipeline_select_column_Pipeline_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: Pipeline_bool_exp
  predicate: Boolean_comparison_exp!
}

input Pipeline_aggregate_bool_exp_bool_or {
  arguments: Pipeline_select_column_Pipeline_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: Pipeline_bool_exp
  predicate: Boolean_comparison_exp!
}

input Pipeline_aggregate_bool_exp_count {
  arguments: [Pipeline_select_column!]
  distinct: Boolean
  filter: Pipeline_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "Pipeline"
"""
input Pipeline_aggregate_order_by {
  count: order_by
  max: Pipeline_max_order_by
  min: Pipeline_min_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input Pipeline_append_input {
  config: jsonb
  node_flow: jsonb
}

"""
input type for inserting array relation for remote table "Pipeline"
"""
input Pipeline_arr_rel_insert_input {
  data: [Pipeline_insert_input!]!
  """
  upsert condition
  """
  on_conflict: Pipeline_on_conflict
}

"""
Boolean expression to filter rows from the table "Pipeline". All fields are combined with a logical 'AND'.
"""
input Pipeline_bool_exp {
  Candidates: Candidate_bool_exp
  Candidates_aggregate: Candidate_aggregate_bool_exp
  Company: Company_bool_exp
  Nodes: PipelineNode_bool_exp
  Nodes_aggregate: PipelineNode_aggregate_bool_exp
  _and: [Pipeline_bool_exp!]
  _not: Pipeline_bool_exp
  _or: [Pipeline_bool_exp!]
  active: Boolean_comparison_exp
  company_id: uuid_comparison_exp
  config: jsonb_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  job_description: String_comparison_exp
  job_title: String_comparison_exp
  job_type: String_comparison_exp
  location: String_comparison_exp
  name: String_comparison_exp
  node_flow: jsonb_comparison_exp
  updated_at: timestamptz_comparison_exp
  workplace_type: String_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Pipeline_delete_at_path_input {
  config: [String!]
  node_flow: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input Pipeline_delete_elem_input {
  config: Int
  node_flow: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Pipeline_delete_key_input {
  config: String
  node_flow: String
}

"""
input type for inserting data into table "Pipeline"
"""
input Pipeline_insert_input {
  Candidates: Candidate_arr_rel_insert_input
  Company: Company_obj_rel_insert_input
  Nodes: PipelineNode_arr_rel_insert_input
  active: Boolean
  company_id: uuid
  config: jsonb
  created_at: timestamptz
  id: uuid
  job_description: String
  job_title: String
  job_type: String
  location: String
  name: String
  node_flow: jsonb
  updated_at: timestamptz
  workplace_type: String
}

"""
order by max() on columns of table "Pipeline"
"""
input Pipeline_max_order_by {
  company_id: order_by
  created_at: order_by
  id: order_by
  job_description: order_by
  job_title: order_by
  job_type: order_by
  location: order_by
  name: order_by
  updated_at: order_by
  workplace_type: order_by
}

"""
order by min() on columns of table "Pipeline"
"""
input Pipeline_min_order_by {
  company_id: order_by
  created_at: order_by
  id: order_by
  job_description: order_by
  job_title: order_by
  job_type: order_by
  location: order_by
  name: order_by
  updated_at: order_by
  workplace_type: order_by
}

"""
input type for inserting object relation for remote table "Pipeline"
"""
input Pipeline_obj_rel_insert_input {
  data: Pipeline_insert_input!
  """
  upsert condition
  """
  on_conflict: Pipeline_on_conflict
}

"""
on_conflict condition type for table "Pipeline"
"""
input Pipeline_on_conflict {
  constraint: Pipeline_constraint!
  update_columns: [Pipeline_update_column!]! = []
  where: Pipeline_bool_exp
}

"""
Ordering options when selecting data from "Pipeline".
"""
input Pipeline_order_by {
  Candidates_aggregate: Candidate_aggregate_order_by
  Company: Company_order_by
  Nodes_aggregate: PipelineNode_aggregate_order_by
  active: order_by
  company_id: order_by
  config: order_by
  created_at: order_by
  id: order_by
  job_description: order_by
  job_title: order_by
  job_type: order_by
  location: order_by
  name: order_by
  node_flow: order_by
  updated_at: order_by
  workplace_type: order_by
}

"""
primary key columns input for table: Pipeline
"""
input Pipeline_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input Pipeline_prepend_input {
  config: jsonb
  node_flow: jsonb
}

"""
input type for updating data in table "Pipeline"
"""
input Pipeline_set_input {
  active: Boolean
  company_id: uuid
  config: jsonb
  created_at: timestamptz
  id: uuid
  job_description: String
  job_title: String
  job_type: String
  location: String
  name: String
  node_flow: jsonb
  updated_at: timestamptz
  workplace_type: String
}

"""
Streaming cursor of the table "Pipeline"
"""
input Pipeline_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Pipeline_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Pipeline_stream_cursor_value_input {
  active: Boolean
  company_id: uuid
  config: jsonb
  created_at: timestamptz
  id: uuid
  job_description: String
  job_title: String
  job_type: String
  location: String
  name: String
  node_flow: jsonb
  updated_at: timestamptz
  workplace_type: String
}

input Pipeline_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: Pipeline_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: Pipeline_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: Pipeline_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: Pipeline_delete_key_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: Pipeline_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Pipeline_set_input
  """
  filter the rows which have to be updated
  """
  where: Pipeline_bool_exp!
}

input PipelineNode_aggregate_bool_exp {
  count: PipelineNode_aggregate_bool_exp_count
}

input PipelineNode_aggregate_bool_exp_count {
  arguments: [PipelineNode_select_column!]
  distinct: Boolean
  filter: PipelineNode_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "PipelineNode"
"""
input PipelineNode_aggregate_order_by {
  avg: PipelineNode_avg_order_by
  count: order_by
  max: PipelineNode_max_order_by
  min: PipelineNode_min_order_by
  stddev: PipelineNode_stddev_order_by
  stddev_pop: PipelineNode_stddev_pop_order_by
  stddev_samp: PipelineNode_stddev_samp_order_by
  sum: PipelineNode_sum_order_by
  var_pop: PipelineNode_var_pop_order_by
  var_samp: PipelineNode_var_samp_order_by
  variance: PipelineNode_variance_order_by
}

"""
append existing jsonb value of filtered columns with new jsonb value
"""
input PipelineNode_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "PipelineNode"
"""
input PipelineNode_arr_rel_insert_input {
  data: [PipelineNode_insert_input!]!
  """
  upsert condition
  """
  on_conflict: PipelineNode_on_conflict
}

"""
order by avg() on columns of table "PipelineNode"
"""
input PipelineNode_avg_order_by {
  node_flow_id: order_by
}

"""
Boolean expression to filter rows from the table "PipelineNode". All fields are combined with a logical 'AND'.
"""
input PipelineNode_bool_exp {
  CandidateResponses: CandidateNodeResponse_bool_exp
  CandidateResponses_aggregate: CandidateNodeResponse_aggregate_bool_exp
  Pipeline: Pipeline_bool_exp
  _and: [PipelineNode_bool_exp!]
  _not: PipelineNode_bool_exp
  _or: [PipelineNode_bool_exp!]
  id: uuid_comparison_exp
  metadata: jsonb_comparison_exp
  node_flow_id: Int_comparison_exp
  pipeline_id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input PipelineNode_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input PipelineNode_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input PipelineNode_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "PipelineNode"
"""
input PipelineNode_inc_input {
  node_flow_id: Int
}

"""
input type for inserting data into table "PipelineNode"
"""
input PipelineNode_insert_input {
  CandidateResponses: CandidateNodeResponse_arr_rel_insert_input
  Pipeline: Pipeline_obj_rel_insert_input
  id: uuid
  metadata: jsonb
  node_flow_id: Int
  pipeline_id: uuid
  type: String
}

"""
order by max() on columns of table "PipelineNode"
"""
input PipelineNode_max_order_by {
  id: order_by
  node_flow_id: order_by
  pipeline_id: order_by
  type: order_by
}

"""
order by min() on columns of table "PipelineNode"
"""
input PipelineNode_min_order_by {
  id: order_by
  node_flow_id: order_by
  pipeline_id: order_by
  type: order_by
}

"""
input type for inserting object relation for remote table "PipelineNode"
"""
input PipelineNode_obj_rel_insert_input {
  data: PipelineNode_insert_input!
  """
  upsert condition
  """
  on_conflict: PipelineNode_on_conflict
}

"""
on_conflict condition type for table "PipelineNode"
"""
input PipelineNode_on_conflict {
  constraint: PipelineNode_constraint!
  update_columns: [PipelineNode_update_column!]! = []
  where: PipelineNode_bool_exp
}

"""
Ordering options when selecting data from "PipelineNode".
"""
input PipelineNode_order_by {
  CandidateResponses_aggregate: CandidateNodeResponse_aggregate_order_by
  Pipeline: Pipeline_order_by
  id: order_by
  metadata: order_by
  node_flow_id: order_by
  pipeline_id: order_by
  type: order_by
}

"""
primary key columns input for table: PipelineNode
"""
input PipelineNode_pk_columns_input {
  id: uuid!
}

"""
prepend existing jsonb value of filtered columns with new jsonb value
"""
input PipelineNode_prepend_input {
  metadata: jsonb
}

"""
input type for updating data in table "PipelineNode"
"""
input PipelineNode_set_input {
  id: uuid
  metadata: jsonb
  node_flow_id: Int
  pipeline_id: uuid
  type: String
}

"""
order by stddev() on columns of table "PipelineNode"
"""
input PipelineNode_stddev_order_by {
  node_flow_id: order_by
}

"""
order by stddev_pop() on columns of table "PipelineNode"
"""
input PipelineNode_stddev_pop_order_by {
  node_flow_id: order_by
}

"""
order by stddev_samp() on columns of table "PipelineNode"
"""
input PipelineNode_stddev_samp_order_by {
  node_flow_id: order_by
}

"""
Streaming cursor of the table "PipelineNode"
"""
input PipelineNode_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: PipelineNode_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input PipelineNode_stream_cursor_value_input {
  id: uuid
  metadata: jsonb
  node_flow_id: Int
  pipeline_id: uuid
  type: String
}

"""
order by sum() on columns of table "PipelineNode"
"""
input PipelineNode_sum_order_by {
  node_flow_id: order_by
}

input PipelineNode_updates {
  """
  append existing jsonb value of filtered columns with new jsonb value
  """
  _append: PipelineNode_append_input
  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: PipelineNode_delete_at_path_input
  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: PipelineNode_delete_elem_input
  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: PipelineNode_delete_key_input
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: PipelineNode_inc_input
  """
  prepend existing jsonb value of filtered columns with new jsonb value
  """
  _prepend: PipelineNode_prepend_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: PipelineNode_set_input
  """
  filter the rows which have to be updated
  """
  where: PipelineNode_bool_exp!
}

"""
order by var_pop() on columns of table "PipelineNode"
"""
input PipelineNode_var_pop_order_by {
  node_flow_id: order_by
}

"""
order by var_samp() on columns of table "PipelineNode"
"""
input PipelineNode_var_samp_order_by {
  node_flow_id: order_by
}

"""
order by variance() on columns of table "PipelineNode"
"""
input PipelineNode_variance_order_by {
  node_flow_id: order_by
}

input RegisterUserInput {
  email: String!
  password: String!
}

input ResetPasswordInput {
  password: String!
  resetToken: String!
}

"""
Boolean expression to filter rows from the table "Role". All fields are combined with a logical 'AND'.
"""
input Role_bool_exp {
  Skills: Skill_Role_bool_exp
  Skills_aggregate: Skill_Role_aggregate_bool_exp
  _and: [Role_bool_exp!]
  _not: Role_bool_exp
  _or: [Role_bool_exp!]
  id: uuid_comparison_exp
  label: String_comparison_exp
}

"""
input type for inserting data into table "Role"
"""
input Role_insert_input {
  Skills: Skill_Role_arr_rel_insert_input
  id: uuid
  label: String
}

"""
input type for inserting object relation for remote table "Role"
"""
input Role_obj_rel_insert_input {
  data: Role_insert_input!
  """
  upsert condition
  """
  on_conflict: Role_on_conflict
}

"""
on_conflict condition type for table "Role"
"""
input Role_on_conflict {
  constraint: Role_constraint!
  update_columns: [Role_update_column!]! = []
  where: Role_bool_exp
}

"""
Ordering options when selecting data from "Role".
"""
input Role_order_by {
  Skills_aggregate: Skill_Role_aggregate_order_by
  id: order_by
  label: order_by
}

"""
primary key columns input for table: Role
"""
input Role_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "Role"
"""
input Role_set_input {
  id: uuid
  label: String
}

"""
Streaming cursor of the table "Role"
"""
input Role_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Role_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Role_stream_cursor_value_input {
  id: uuid
  label: String
}

input Role_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Role_set_input
  """
  filter the rows which have to be updated
  """
  where: Role_bool_exp!
}

"""
Boolean expression to filter rows from the table "Skill". All fields are combined with a logical 'AND'.
"""
input Skill_bool_exp {
  Roles: Skill_Role_bool_exp
  Roles_aggregate: Skill_Role_aggregate_bool_exp
  _and: [Skill_bool_exp!]
  _not: Skill_bool_exp
  _or: [Skill_bool_exp!]
  icon_svg: String_comparison_exp
  id: uuid_comparison_exp
  label: String_comparison_exp
}

"""
input type for inserting data into table "Skill"
"""
input Skill_insert_input {
  Roles: Skill_Role_arr_rel_insert_input
  icon_svg: String
  id: uuid
  label: String
}

"""
input type for inserting object relation for remote table "Skill"
"""
input Skill_obj_rel_insert_input {
  data: Skill_insert_input!
  """
  upsert condition
  """
  on_conflict: Skill_on_conflict
}

"""
on_conflict condition type for table "Skill"
"""
input Skill_on_conflict {
  constraint: Skill_constraint!
  update_columns: [Skill_update_column!]! = []
  where: Skill_bool_exp
}

"""
Ordering options when selecting data from "Skill".
"""
input Skill_order_by {
  Roles_aggregate: Skill_Role_aggregate_order_by
  icon_svg: order_by
  id: order_by
  label: order_by
}

"""
primary key columns input for table: Skill
"""
input Skill_pk_columns_input {
  id: uuid!
}

input Skill_Role_aggregate_bool_exp {
  count: Skill_Role_aggregate_bool_exp_count
}

input Skill_Role_aggregate_bool_exp_count {
  arguments: [Skill_Role_select_column!]
  distinct: Boolean
  filter: Skill_Role_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "Skill_Role"
"""
input Skill_Role_aggregate_order_by {
  count: order_by
  max: Skill_Role_max_order_by
  min: Skill_Role_min_order_by
}

"""
input type for inserting array relation for remote table "Skill_Role"
"""
input Skill_Role_arr_rel_insert_input {
  data: [Skill_Role_insert_input!]!
  """
  upsert condition
  """
  on_conflict: Skill_Role_on_conflict
}

"""
Boolean expression to filter rows from the table "Skill_Role". All fields are combined with a logical 'AND'.
"""
input Skill_Role_bool_exp {
  Role: Role_bool_exp
  Skill: Skill_bool_exp
  _and: [Skill_Role_bool_exp!]
  _not: Skill_Role_bool_exp
  _or: [Skill_Role_bool_exp!]
  id: uuid_comparison_exp
  role_id: uuid_comparison_exp
  skill_id: uuid_comparison_exp
}

"""
input type for inserting data into table "Skill_Role"
"""
input Skill_Role_insert_input {
  Role: Role_obj_rel_insert_input
  Skill: Skill_obj_rel_insert_input
  id: uuid
  role_id: uuid
  skill_id: uuid
}

"""
order by max() on columns of table "Skill_Role"
"""
input Skill_Role_max_order_by {
  id: order_by
  role_id: order_by
  skill_id: order_by
}

"""
order by min() on columns of table "Skill_Role"
"""
input Skill_Role_min_order_by {
  id: order_by
  role_id: order_by
  skill_id: order_by
}

"""
on_conflict condition type for table "Skill_Role"
"""
input Skill_Role_on_conflict {
  constraint: Skill_Role_constraint!
  update_columns: [Skill_Role_update_column!]! = []
  where: Skill_Role_bool_exp
}

"""
Ordering options when selecting data from "Skill_Role".
"""
input Skill_Role_order_by {
  Role: Role_order_by
  Skill: Skill_order_by
  id: order_by
  role_id: order_by
  skill_id: order_by
}

"""
primary key columns input for table: Skill_Role
"""
input Skill_Role_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "Skill_Role"
"""
input Skill_Role_set_input {
  id: uuid
  role_id: uuid
  skill_id: uuid
}

"""
Streaming cursor of the table "Skill_Role"
"""
input Skill_Role_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Skill_Role_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Skill_Role_stream_cursor_value_input {
  id: uuid
  role_id: uuid
  skill_id: uuid
}

input Skill_Role_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Skill_Role_set_input
  """
  filter the rows which have to be updated
  """
  where: Skill_Role_bool_exp!
}

"""
input type for updating data in table "Skill"
"""
input Skill_set_input {
  icon_svg: String
  id: uuid
  label: String
}

"""
Streaming cursor of the table "Skill"
"""
input Skill_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Skill_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Skill_stream_cursor_value_input {
  icon_svg: String
  id: uuid
  label: String
}

input Skill_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Skill_set_input
  """
  filter the rows which have to be updated
  """
  where: Skill_bool_exp!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  """
  does the column match the given case-insensitive pattern
  """
  _ilike: String
  _in: [String!]
  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean
  """
  does the column match the given pattern
  """
  _like: String
  _lt: String
  _lte: String
  _neq: String
  """
  does the column NOT match the given case-insensitive pattern
  """
  _nilike: String
  _nin: [String!]
  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String
  """
  does the column NOT match the given pattern
  """
  _nlike: String
  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String
  """
  does the column NOT match the given SQL regular expression
  """
  _nsimilar: String
  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String
  """
  does the column match the given SQL regular expression
  """
  _similar: String
}

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

input Transaction_aggregate_bool_exp {
  avg: Transaction_aggregate_bool_exp_avg
  corr: Transaction_aggregate_bool_exp_corr
  count: Transaction_aggregate_bool_exp_count
  covar_samp: Transaction_aggregate_bool_exp_covar_samp
  max: Transaction_aggregate_bool_exp_max
  min: Transaction_aggregate_bool_exp_min
  stddev_samp: Transaction_aggregate_bool_exp_stddev_samp
  sum: Transaction_aggregate_bool_exp_sum
  var_samp: Transaction_aggregate_bool_exp_var_samp
}

input Transaction_aggregate_bool_exp_avg {
  arguments: Transaction_select_column_Transaction_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: float8_comparison_exp!
}

input Transaction_aggregate_bool_exp_corr {
  arguments: Transaction_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: float8_comparison_exp!
}

input Transaction_aggregate_bool_exp_corr_arguments {
  X: Transaction_select_column_Transaction_aggregate_bool_exp_corr_arguments_columns!
  Y: Transaction_select_column_Transaction_aggregate_bool_exp_corr_arguments_columns!
}

input Transaction_aggregate_bool_exp_count {
  arguments: [Transaction_select_column!]
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: Int_comparison_exp!
}

input Transaction_aggregate_bool_exp_covar_samp {
  arguments: Transaction_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: float8_comparison_exp!
}

input Transaction_aggregate_bool_exp_covar_samp_arguments {
  X: Transaction_select_column_Transaction_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: Transaction_select_column_Transaction_aggregate_bool_exp_covar_samp_arguments_columns!
}

input Transaction_aggregate_bool_exp_max {
  arguments: Transaction_select_column_Transaction_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: float8_comparison_exp!
}

input Transaction_aggregate_bool_exp_min {
  arguments: Transaction_select_column_Transaction_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: float8_comparison_exp!
}

input Transaction_aggregate_bool_exp_stddev_samp {
  arguments: Transaction_select_column_Transaction_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: float8_comparison_exp!
}

input Transaction_aggregate_bool_exp_sum {
  arguments: Transaction_select_column_Transaction_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: float8_comparison_exp!
}

input Transaction_aggregate_bool_exp_var_samp {
  arguments: Transaction_select_column_Transaction_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: Transaction_bool_exp
  predicate: float8_comparison_exp!
}

"""
order by aggregate values of table "Transaction"
"""
input Transaction_aggregate_order_by {
  avg: Transaction_avg_order_by
  count: order_by
  max: Transaction_max_order_by
  min: Transaction_min_order_by
  stddev: Transaction_stddev_order_by
  stddev_pop: Transaction_stddev_pop_order_by
  stddev_samp: Transaction_stddev_samp_order_by
  sum: Transaction_sum_order_by
  var_pop: Transaction_var_pop_order_by
  var_samp: Transaction_var_samp_order_by
  variance: Transaction_variance_order_by
}

"""
input type for inserting array relation for remote table "Transaction"
"""
input Transaction_arr_rel_insert_input {
  data: [Transaction_insert_input!]!
  """
  upsert condition
  """
  on_conflict: Transaction_on_conflict
}

"""
order by avg() on columns of table "Transaction"
"""
input Transaction_avg_order_by {
  amount: order_by
}

"""
Boolean expression to filter rows from the table "Transaction". All fields are combined with a logical 'AND'.
"""
input Transaction_bool_exp {
  Company: Company_bool_exp
  _and: [Transaction_bool_exp!]
  _not: Transaction_bool_exp
  _or: [Transaction_bool_exp!]
  amount: float8_comparison_exp
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  type: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "Transaction"
"""
input Transaction_inc_input {
  amount: float8
}

"""
input type for inserting data into table "Transaction"
"""
input Transaction_insert_input {
  Company: Company_obj_rel_insert_input
  amount: float8
  company_id: uuid
  created_at: timestamptz
  id: uuid
  type: String
}

"""
order by max() on columns of table "Transaction"
"""
input Transaction_max_order_by {
  amount: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  type: order_by
}

"""
order by min() on columns of table "Transaction"
"""
input Transaction_min_order_by {
  amount: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  type: order_by
}

"""
on_conflict condition type for table "Transaction"
"""
input Transaction_on_conflict {
  constraint: Transaction_constraint!
  update_columns: [Transaction_update_column!]! = []
  where: Transaction_bool_exp
}

"""
Ordering options when selecting data from "Transaction".
"""
input Transaction_order_by {
  Company: Company_order_by
  amount: order_by
  company_id: order_by
  created_at: order_by
  id: order_by
  type: order_by
}

"""
primary key columns input for table: Transaction
"""
input Transaction_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "Transaction"
"""
input Transaction_set_input {
  amount: float8
  company_id: uuid
  created_at: timestamptz
  id: uuid
  type: String
}

"""
order by stddev() on columns of table "Transaction"
"""
input Transaction_stddev_order_by {
  amount: order_by
}

"""
order by stddev_pop() on columns of table "Transaction"
"""
input Transaction_stddev_pop_order_by {
  amount: order_by
}

"""
order by stddev_samp() on columns of table "Transaction"
"""
input Transaction_stddev_samp_order_by {
  amount: order_by
}

"""
Streaming cursor of the table "Transaction"
"""
input Transaction_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: Transaction_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input Transaction_stream_cursor_value_input {
  amount: float8
  company_id: uuid
  created_at: timestamptz
  id: uuid
  type: String
}

"""
order by sum() on columns of table "Transaction"
"""
input Transaction_sum_order_by {
  amount: order_by
}

input Transaction_updates {
  """
  increments the numeric columns with given value of the filtered values
  """
  _inc: Transaction_inc_input
  """
  sets the columns of the filtered rows to the given values
  """
  _set: Transaction_set_input
  """
  filter the rows which have to be updated
  """
  where: Transaction_bool_exp!
}

"""
order by var_pop() on columns of table "Transaction"
"""
input Transaction_var_pop_order_by {
  amount: order_by
}

"""
order by var_samp() on columns of table "Transaction"
"""
input Transaction_var_samp_order_by {
  amount: order_by
}

"""
order by variance() on columns of table "Transaction"
"""
input Transaction_variance_order_by {
  amount: order_by
}

input User_aggregate_bool_exp {
  count: User_aggregate_bool_exp_count
}

input User_aggregate_bool_exp_count {
  arguments: [User_select_column!]
  distinct: Boolean
  filter: User_bool_exp
  predicate: Int_comparison_exp!
}

"""
order by aggregate values of table "User"
"""
input User_aggregate_order_by {
  count: order_by
  max: User_max_order_by
  min: User_min_order_by
}

"""
input type for inserting array relation for remote table "User"
"""
input User_arr_rel_insert_input {
  data: [User_insert_input!]!
  """
  upsert condition
  """
  on_conflict: User_on_conflict
}

"""
Boolean expression to filter rows from the table "User". All fields are combined with a logical 'AND'.
"""
input User_bool_exp {
  Company: Company_bool_exp
  _and: [User_bool_exp!]
  _not: User_bool_exp
  _or: [User_bool_exp!]
  company_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  email: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  password_hash: String_comparison_exp
  password_reset_token: String_comparison_exp
  status: String_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
input type for inserting data into table "User"
"""
input User_insert_input {
  Company: Company_obj_rel_insert_input
  company_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  password_hash: String
  password_reset_token: String
  status: String
  updated_at: timestamptz
}

"""
order by max() on columns of table "User"
"""
input User_max_order_by {
  company_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  password_hash: order_by
  password_reset_token: order_by
  status: order_by
  updated_at: order_by
}

"""
order by min() on columns of table "User"
"""
input User_min_order_by {
  company_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  password_hash: order_by
  password_reset_token: order_by
  status: order_by
  updated_at: order_by
}

"""
on_conflict condition type for table "User"
"""
input User_on_conflict {
  constraint: User_constraint!
  update_columns: [User_update_column!]! = []
  where: User_bool_exp
}

"""
Ordering options when selecting data from "User".
"""
input User_order_by {
  Company: Company_order_by
  company_id: order_by
  created_at: order_by
  email: order_by
  id: order_by
  name: order_by
  password_hash: order_by
  password_reset_token: order_by
  status: order_by
  updated_at: order_by
}

"""
primary key columns input for table: User
"""
input User_pk_columns_input {
  id: uuid!
}

"""
input type for updating data in table "User"
"""
input User_set_input {
  company_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  password_hash: String
  password_reset_token: String
  status: String
  updated_at: timestamptz
}

"""
Streaming cursor of the table "User"
"""
input User_stream_cursor_input {
  """
  Stream column input with initial value
  """
  initial_value: User_stream_cursor_value_input!
  """
  cursor ordering
  """
  ordering: cursor_ordering
}

"""
Initial value of the column from where the streaming should start
"""
input User_stream_cursor_value_input {
  company_id: uuid
  created_at: timestamptz
  email: String
  id: uuid
  name: String
  password_hash: String
  password_reset_token: String
  status: String
  updated_at: timestamptz
}

input User_updates {
  """
  sets the columns of the filtered rows to the given values
  """
  _set: User_set_input
  """
  filter the rows which have to be updated
  """
  where: User_bool_exp!
}

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

input VerifyCompanyMemberInput {
  password: String!
  token: String!
}

"""
whether this query should be included
"""
directive @include(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
whether this query should be skipped
"""
directive @skip(if: Boolean!) on FIELD | FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
whether this query should be cached (Hasura Cloud only)
"""
directive @cached(ttl: Int! = 60, refresh: Boolean! = false) on QUERY

